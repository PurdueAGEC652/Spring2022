<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>AGEC 652 - Lecture 1.3</title>
    <meta charset="utf-8" />
    <meta name="author" content="Diego S. Cardoso" />
    <script src="1_3_julia_files/header-attrs-2.11/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# AGEC 652 - Lecture 1.3
## An introduction to Julia
### Diego S. Cardoso
### Spring 2022

---

exclude: true

```r
if (!require("pacman")) install.packages("pacman")
```

```
## Loading required package: pacman
```

```r
pacman::p_load(
  xaringanthemer, JuliaCall
)

#options(htmltools.dir.version = FALSE)

knitr::opts_hooks$set(fig.callout = function(options) {
  if (options$fig.callout) {
    options$echo &lt;- FALSE
  }

  knitr::opts_chunk$set(echo = TRUE, fig.align="center")
  options
})
```




```julia
using Pkg
Pkg.activate(".")
Pkg.instantiate()
Pkg.add("BenchmarkTools")
```



---

## Software requirements

By now you hopefully have installed
- Julia

- Visual Studio Code with Julia extension
- Jupyter
  - We will take a quick look on how to use VS Code and Jupyter


---

class: inverse, center, middle

# Programming with Julia

.footnote[\*These slides are based on Software Carpentry, notes by Ivan Rudik and Grant Mcdermott, QuantEcon, and Julia documentation.]

---

## Why learn Julia?

**Reason 1: It is easy to learn and use**

Julia is a *high-level* language
- Low-level = you write instructions are closer to what the hardware understands (Assembly, C++, Fortran)
  - .small[E.g.: ]
  - .small[These are usually the fastest because there is little to translate (what a compiler does) and you can optimize your code depending on your hardware]
- High-level means you write in closer to human language (Julia, R, Python)
  - .small[The compiler has to do a lot more work to translate your instructions]

---

## Why learn Julia?

**Reason 2: Julia delivers C++ and Fortran speed**

.small[Sounds like magic, but it's just a clever combination of design choices targeting numerical methods]

&lt;div align="center"&gt;
  &lt;img src="figures/julia_speed_2.png" height=300&gt;
&lt;/div&gt;

.center[.footnote[*In this graph, time to execute in C++ is 1]]

---

## Why learn Julia?

**Reason 3: Julia is free, open-source, and popular**

- You don't need expensive licenses to use (unlike Matlab)

- The people who want to use or verify what you did also don't have to pay

- There is a large and active community of users and developers
  - So it's easy to get help and new packages


---

## .blue[Time for an IDE showcase]

We'll stop the slide show for a while to see two recommended *Integrated Development Environments*, or *IDEs*

- Visual Studio (VS) code

- Jupyter Lab notebooks


---


## Intro to programming

### Programming `\(\equiv\)` writing a set of instructions

- There are hard rules you can't break if you want your code to work

--

- There are elements of style (e.g. Strunk and White) that make your code easier to read, modify, and maintain

--

- There are elements that make your code more efficient
  - Using less time or space (memory)


---

## Intro to programming

If you will be doing computational work, there are:

1. Language-independent coding basics you should know
    - Arrays are stored in memory in particular ways
    
2. Language-independent best practices you should use
    - Indent to convey program structure, naming conventions
    
3. Language-dependent idiosyncracies that matter for function, speed, etc
    - Julia: type stability; R: vectorize

---

## Intro to programming

Learning these early will:

1. Make coding a lot easier
--

2. Reduce total programmer time
--

3. Reduce total computer time
--

4. Make your code understandable by someone else or your future self
--

5. Make your code flexible

---

## A broad view of programming

Your goal is to make a **program**

A program is made of different components and sub-components

--

The most basic component is a **statement**, more commonly called a **line of code**


---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
*deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:

1. Create a deck of cards

---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
*shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:
1. Create a deck of cards
2. Shuffle the deck

---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
*first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:
1. Create a deck of cards
2. Shuffle the deck
3. Draw the top card

---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
*println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:
1. Create a deck of cards
2. Shuffle the deck
3. Draw the top card
4. Print it

---

## A broad view of programming

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

What are the parentheses and why are they different from square brackets?

How does shuffle work?

What’s `println`?

It’s important to know that a **good program has understandable code**

---

## Julia specifics

We will discuss coding in the context of Julia
but a lot of this ports to Python, MATLAB, etc&lt;sup&gt;1&lt;/sup&gt;

We will review

1. Types
2. Iteration
3. Broadcasting/vectorization
4. Scope
5. Generic functions
6. Multiple dispatch


.footnote[&lt;sup&gt;1&lt;/sup&gt;See [https://cheatsheets.quantecon.org](https://cheatsheets.quantecon.org)]

---

## Types: boolean

All languages have some kind of **variable types** like *integers* or *arrays*

--

The first type you will often use is a boolean (`Bool`) variable that takes on a value of `true` or `false`:

```julia
x = true
```

```
## true
```

```julia
typeof(x)
```

```
## Bool
```

---

## Types: boolean

We can save the boolean value of actual statements in variables this way:

```julia
@show y = 1 &gt; 2
```

```
## y = 1 &gt; 2 = false
```

```
## false
```

`@show` is a Julia macro for showing the operation. 
- .small[You can think of a macro as a shortcut name that calls a bunch of other things to run]

---

## Quick detour: logical operators

Logical operators work like you'd think

`==` (equal equal) tests for equality


```julia
1 == 1
```

```
## true
```

--

`!=` (exclaimation point equal) tests for inequality


```julia
2 != 2
```

```
## false
```

---

## Quick detour: logical operators


You can also test for approximate equality with `\(\approx\)` (type `\approx&lt;TAB&gt;`)



```julia
1.00000001 ≈ 1
```

```
## true
```

--

Now back to types

---

## Types: numbers

Two other data types you will use frequently are integers

```julia
typeof(1)
```

```
## Int64
```

--

and floating point numbers

```julia
typeof(1.0)
```

```
## Float64
```

- .small[64 means 64 bits of storage for the number, which is probably the default on your machine]

---

## Types: numbers

You can always instantiate alternative floating point number types


```julia
converted_int = convert(Float32, 1.0);
typeof(converted_int)
```

```
## Float32
```

---

## Types: numbers

### Math works like you would expect:

```julia
a = 2
```

```
## 2
```

```julia
b = 1.0
```

```
## 1.0
```

```julia
a * b
```

```
## 2.0
```

--


```julia
a^2
```

```
## 4
```

---

## Types: numbers


```julia
2a - 4b
```

```
## 0.0
```

--


```julia
@show 4a + 3b^2
```

```
## 4a + 3 * b ^ 2 = 11.0
```

```
## 11.0
```

--

.blue[In Julia, you dont need `*` in between numeric literals (numbers) and variables]

---

## Types: strings

Strings store sequences of characters

You implement them with double quotations:


```julia
x = "Hello World!";
typeof(x)
```

```
## String
```

--

.blue[Note that `;` is used to suppress output for that line of code. Unlike some other languages, in Julia you don't need to add `;` after every command]

---

## Types: strings

It's easy to work with strings. Use `$` to interpolate a variable/expression

```julia
x = 10; y = 20; println("x + y =  $(x+y).")
```

```
## x + y =  30.
```

--

Use `*` to concatenate strings

```julia
a = "Aww"; b = "Yeah!!!"; println(a * " " * b)
```

```
## Aww Yeah!!!
```

--

You probably won't use strings too often unless you're working with text data or printing output. 
--
.blue[Note that `;` can also be used to type multiple commands in the same line. I'm doing it make it fit in this slide, but you should avoid it]


---

## Types: containers

Containers are types that store collections of data

--

The most basic container is the `Array` which is denoted by square brackets

--



```julia
a1 = [1 2; 3 4]; typeof(a1)
```

```
## Matrix{Int64} (alias for Array{Int64, 2})
```

--

Arrays are **mutable**, which means you can change their values

--


```julia
a1[1,1] = 5; a1
```

```
## 2×2 Matrix{Int64}:
##  5  2
##  3  4
```

You reference elements in a container with square brackets

---

## Types: containers

An alternative to the `Array` is the `Tuple`, which is denoted by parentheses

--


```julia
a2 = (1, 2, 3, 4); typeof(a2)
```

```
## NTuple{4, Int64}
```
`a2` is a `Tuple` of 4 `Int64`s. Tuples have no dimension

---

## Types: containers

Tuples are **immutable** which means you **can't** change their values

```julia
try
  a2[1,1] = 5;
catch
  println("Error, can't change value of a tuple.")
end
```

```
## Error, can't change value of a tuple.
```

---

## Types: containers

Tuples don't need parentheses (but it's probably best practice for clarity)

```julia
a3 = 5, 6; typeof(a3)
```

```
## Tuple{Int64, Int64}
```

---

## Types: containers

Tuples can be **unpacked** 

--


```julia
a3_x, a3_y = a3;
a3_x
```

```
## 5
```

```julia
a3_y
```

```
## 6
```

--

This is basically how functions return output when you call them

---

## Types: containers

But an alternative and more efficient container is the  [`NamedTuple`](https://docs.julialang.org/en/v1/manual/types/#Named-Tuple-Types-1) 


```julia
nt = (x = 10, y = 11); typeof(nt)
```

```
## NamedTuple{(:x, :y), Tuple{Int64, Int64}}
```

```julia
nt.x
```

```
## 10
```

```julia
nt.y
```

```
## 11
```

Another way of accessing `x` and `y` inside the NamedTuple is


```julia
nt[:x]; nt[:y];
```


---

## Types: containers

A `Dictionary` is the last main container type. They are like arrays but are indexed by keys (names) instead of numbers

--


```julia
d1 = Dict("class" =&gt; "AEM7130", "grade" =&gt; 97);
typeof(d1)
```

```
## Dict{String, Any}
```

--

`d1` is a dictionary where the key are strings and the values are any kind of type

---

## Types: containers

Reference specific values you want in the dictionary by referencing the key

--


```julia
d1["class"]
```

```
## "AEM7130"
```

```julia
d1["grade"]
```

```
## 97
```

---

## Types: containers

If you just want all the keys or all the values, you can use these base functions


```julia
keys_d1 = keys(d1)
```

```
## KeySet for a Dict{String, Any} with 2 entries. Keys:
##   "class"
##   "grade"
```

```julia
values_d1 = values(d1)
```

```
## ValueIterator for a Dict{String, Any} with 2 entries. Values:
##   "AEM7130"
##   97
```

---

## Iterating

As in other languages we have loops at our disposal:

`for` loops iterate over containers

```julia
for count in 1:10
  random_number = rand()
  if random_number &gt; 0.2
    println("We drew a $random_number.")
  end
end
```

```
## We drew a 0.8247227329122151.
## We drew a 0.41954394564971.
## We drew a 0.7338209660484674.
## We drew a 0.2634959228001874.
## We drew a 0.8790571954490457.
## We drew a 0.7230963200163567.
## We drew a 0.23627640919794224.
## We drew a 0.9480017578757083.
## We drew a 0.9763580625222854.
```

---

## Iterating

`while` loops iterate until a logical expression is false

```julia
while rand() &gt; 0.5
  random_number = rand()
  if random_number &gt; 0.2
    println("We drew a $random_number.")
  end
end
```

---

## Iterating

An `Iterable` is something you can loop over, like arrays

--


```julia
actions = ["codes well", "skips class"];
for action in actions
    println("Charlie $action")
end
```

```
## Charlie codes well
## Charlie skips class
```

---

## Iterating

The type `Iterator` is a particularly convenient subset of Iterables

--

These include things like the dictionary keys:

```julia
for key in keys(d1)
  println(d1[key])
end
```

```
## AEM7130
## 97
```

---

## Iterating

Iterating on `Iterator`s is more *memory efficient* than iterating on arrays

--

Here's a **very** simple example. The top function iterates on an `Array`, the bottom function iterates on an `Iterator`:

--


```julia
function show_array_speed()
  m = 1
  for i = [1, 2, 3, 4, 5, 6]
    m = m*i
  end
end;

function show_iterator_speed()
  m = 1
  for i = 1:6
    m = m*i
  end
end;
```

---

## Iterating



```julia
using BenchmarkTools
@btime show_array_speed()
```

```
##   25.100 ns (1 allocation: 112 bytes)
```

```julia
@btime show_iterator_speed()
```

```
##   1.800 ns (0 allocations: 0 bytes)
```

The `Iterator` approach is faster and allocates no memory

`@btime` is a macro from `BenchmarkTools` that shows you the elasped time and memory allocation

---

## Neat looping

A nice thing about Julia vs MATLAB: your loops can be much neater because you don't need to index when you just want the container elements

--


```julia
f(x) = x^2;
x_values = 0:20:100;
for x in x_values
  println(f(x))
end
```

```
## 0
## 400
## 1600
## 3600
## 6400
## 10000
```

---

## Neat looping

This loop directly assigns the elements of `x_values` to `x` instead of having to do something clumsy like `x_values[i]`

--

`0:20:100` creates something called a `StepRange` (a type of `Iterator`) which starts at `0`, steps up by `20` and ends at `100`


---

## Neat looping

You can also pull out an index and the element value by enumerating


```julia
f(x) = x^2;
x_values = 0:20:100;
for (index, x) in enumerate(x_values)
  println("f(x) at value $index is $(f(x)).")
end
```

```
## f(x) at value 1 is 0.
## f(x) at value 2 is 400.
## f(x) at value 3 is 1600.
## f(x) at value 4 is 3600.
## f(x) at value 5 is 6400.
## f(x) at value 6 is 10000.
```

`enumerate` basically assigns an index vector

---

## Neat looping

There is also a lot of Python-esque functionality to loop without indexes

For example: `zip` lets you loop over multiple different iterables at once

--


```julia
last_name = ("Lincoln", "Bond", "Walras");
first_name = ("Abraham", "James", "Leon");

for (first_idx, last_idx) in zip(first_name, last_name)
  println("The name's $last_idx, $first_idx $last_idx.")
end
```

```
## The name's Lincoln, Abraham Lincoln.
## The name's Bond, James Bond.
## The name's Walras, Leon Walras.
```

---

## Neat looping

Nested loops can also be made very neatly

--


```julia
for x in 1:3, y in 3:-1:1
  println("$x minus $y is $(x-y)")
end
```

```
## 1 minus 3 is -2
## 1 minus 2 is -1
## 1 minus 1 is 0
## 2 minus 3 is -1
## 2 minus 2 is 0
## 2 minus 1 is 1
## 3 minus 3 is 0
## 3 minus 2 is 1
## 3 minus 1 is 2
```

--

The first loop is the *outer* loop, the second loop is the *inner* loop

---

## Comprehensions: the neatest looping

Comprehensions are an elegant way to use iterables that makes your code cleaner and more compact

--


```julia
squared = [y^2 for y in 1:2:11]
```

```
## 6-element Vector{Int64}:
##    1
##    9
##   25
##   49
##   81
##  121
```

This created a 1-dimension `Array` using one line

---

## Comprehensions: the neatest looping

We can also use nested loops for comprehensions

--


```julia
squared_2 = [(y+z)^2 for y in 1:2:11, z in 1:6]
```

```
## 6×6 Matrix{Int64}:
##    4    9   16   25   36   49
##   16   25   36   49   64   81
##   36   49   64   81  100  121
##   64   81  100  121  144  169
##  100  121  144  169  196  225
##  144  169  196  225  256  289
```

This created a 2-dimensional `Array`

--

Use this (and the compact nested loop) sparingly since it's hard to follow

---

## Vectorization

Iterated operations element by element is usually an inefficient approach

Another way is to do operations over an entire array. This is called **vectorization**

&lt;div style="float: right"&gt;
  &lt;img src="figures/vectorization.png" height=250&gt;
&lt;/div&gt;

- .small[It's faster because your processor can do some operations over multiple values with one instruction]
- .small[We'll get a better idea next lecture when we review the basics of computer architecture]


---

## Dot syntax: broadcasting/vectorization

Vectorizing operations is easy in Julia: just use *dot syntax* (like in MATLAB)

--


```julia
g(x) = x^2;
squared_2 = g.(1:2:11)
```

```
## 6-element Vector{Int64}:
##    1
##    9
##   25
##   49
##   81
##  121
```

--

This is actually called **broadcasting** in Julia


---

## Dot syntax: broadcasting/vectorization

When broadcasting, you might want to consider **pre-allocating** arrays

Vectorization creates *temporary allocations*: temporary arrays in the middle of the process that aren't actually needed for the final product

Julia can do broadcasting in a nicer, faster way by .hi-blue[fusing] operations together and avoiding these temporary allocations

---

## Dot syntax: broadcasting/vectorization

Let's write two functions that do the same thing:


```julia
function show_vec_speed(x)
  out = [3x.^2 + 4x + 7x.^3 for i = 1:1]
end
function show_fuse_speed(x)
  out = @. [3x.^2 + 4x + 7x.^3 for i = 1:1]
end
```

- The top one is vectorized for the operations
- The `@.` in the bottom one vectorizes everything in one swoop: the function call, the operation, and the assignment to a variable

---

## Dot syntax: broadcasting/vectorization

First, precompile the functions


```julia
x = rand(10^6);
@time show_vec_speed(x);
@time show_fuse_speed(x);
```

--

.blue[*Just-in-time compilation* (JIT) is one of the tricks Julia does to make things run faster. It "translates" your code to machine language once and uses that every time you run it again]

---

## Dot syntax: broadcasting/vectorization

Then, let's run and time it


```julia
@time show_vec_speed(x)
```

```
##   0.026681 seconds (13 allocations: 45.777 MiB, 33.09% gc time)
```

```
## 1-element Vector{Vector{Float64}}:
##  [13.947816239077262, 3.5631978133965223, 2.5187747800504776, 5.7225671045096735, 0.5744876892954576, 5.1336885419701, 10.457184615775692, 6.071183877846761, 5.374340578206351, 2.054958849037614  …  0.4336645042207751, 5.177344172945268, 4.555194912920591, 0.8194552510266924, 7.527936567968595, 2.5216972310975105, 13.21513679992367, 4.417596861827281, 0.7381607505286636, 9.970846590925115]
```

```julia
@time show_fuse_speed(x)
```

```
##   0.012246 seconds (3 allocations: 7.630 MiB, 74.42% gc time)
```

```
## 1-element Vector{Vector{Float64}}:
##  [13.947816239077262, 3.5631978133965223, 2.5187747800504776, 5.7225671045096735, 0.5744876892954576, 5.1336885419701, 10.457184615775692, 6.071183877846761, 5.374340578206351, 2.054958849037614  …  0.4336645042207751, 5.177344172945268, 4.555194912920591, 0.8194552510266924, 7.527936567968595, 2.5216972310975105, 13.21513679992367, 4.417596861827281, 0.7381607505286636, 9.970846590925115]
```

Full vectorization using `@.` is 10x faster with 1/6 of the memory allocation

---

## Dot syntax: broadcasting/vectorization

Not pre-allocated:


```julia
h(y,z) = y^2 + sin(z);   # function to evaluate
y = 1:2:1e6+1;           # input y
z = rand(length(y));     # input z
```

---

## Dot syntax: broadcasting/vectorization

Here we are vectorizing the *function call*


```julia
# precompile h so first timer isn't picking up on compilation time
h(1,2);
```


```julia
@time h_out_1 = h.(y,z)    # evaluate h.(y,z) and time
```

```
##   0.071511 seconds (217.48 k allocations: 15.152 MiB, 93.46% compilation time)
```

```
## 500001-element Vector{Float64}:
##    1.646473371686329
##    9.550373995967727
##   25.18535356707042
##   49.75676756941773
##   81.49017599455534
##  121.70599255879272
##  169.56853539258532
##  225.58123383404813
##  289.3122464388625
##  361.4965135832412
##    ⋮
##    9.999700002257589e11
##    9.999740001692437e11
##    9.999780001210995e11
##    9.999820000812405e11
##    9.999860000497021e11
##    9.999900000258047e11
##    9.999940000095876e11
##    9.999980000013203e11
##    1.0000020000017223e12
```

---
## Dot syntax: broadcasting/vectorization

Here we are vectorizing the *function call* **and** *assignment*


```julia
h_out_2 = similar(h_out_1) # This pre-alocates memory for an object of the same type and size
```


```julia
@time h_out_2 .= h.(y,z)
```

```
##   0.035146 seconds (48.63 k allocations: 2.340 MiB, 76.47% compilation time)
```

```
## 500001-element Vector{Float64}:
##    1.646473371686329
##    9.550373995967727
##   25.18535356707042
##   49.75676756941773
##   81.49017599455534
##  121.70599255879272
##  169.56853539258532
##  225.58123383404813
##  289.3122464388625
##  361.4965135832412
##    ⋮
##    9.999700002257589e11
##    9.999740001692437e11
##    9.999780001210995e11
##    9.999820000812405e11
##    9.999860000497021e11
##    9.999900000258047e11
##    9.999940000095876e11
##    9.999980000013203e11
##    1.0000020000017223e12
```

---
## Dot syntax: broadcasting/vectorization

Here we are vectorizing the *function call* **and** *assignment* **and** even the *operations* inside the function


```julia
h_out_3 = similar(h_out_1)
```

```julia
@time @. h_out_3 = h(y,z)
```

```
##   0.004762 seconds (2 allocations: 128 bytes)
```

```
## 500001-element Vector{Float64}:
##    1.646473371686329
##    9.550373995967727
##   25.18535356707042
##   49.75676756941773
##   81.49017599455534
##  121.70599255879272
##  169.56853539258532
##  225.58123383404813
##  289.3122464388625
##  361.4965135832412
##    ⋮
##    9.999700002257589e11
##    9.999740001692437e11
##    9.999780001210995e11
##    9.999820000812405e11
##    9.999860000497021e11
##    9.999900000258047e11
##    9.999940000095876e11
##    9.999980000013203e11
##    1.0000020000017223e12
```

---

## Dot syntax: broadcasting/vectorization

The `@.` macro saves us from typing a bunch of `.`


```julia
h_vec(y,z) = y.^2 + sin.(z); h_vec(1,2); h_out_4 = similar(h_out_1)
```

```julia
@time h_out_4 .= h.(y,z)
```

```
##   0.004391 seconds (2 allocations: 128 bytes)
```

```
## 500001-element Vector{Float64}:
##    1.646473371686329
##    9.550373995967727
##   25.18535356707042
##   49.75676756941773
##   81.49017599455534
##  121.70599255879272
##  169.56853539258532
##  225.58123383404813
##  289.3122464388625
##  361.4965135832412
##    ⋮
##    9.999700002257589e11
##    9.999740001692437e11
##    9.999780001210995e11
##    9.999820000812405e11
##    9.999860000497021e11
##    9.999900000258047e11
##    9.999940000095876e11
##    9.999980000013203e11
##    1.0000020000017223e12
```


---

## Scope


The **scope** of a variable name determines when it is valid to refer to that variable
  - E.g.: if you create a variable inside a function, can you reference that variable outside the function?
  - You can think of scope as different contexts within your program

--
  
The two basic scopes are **local** and **global**

--

Scope can be a frustrating concept to grasp at first. But understanding how scopes work can save you a lot of debugging time

--

Let's walk through some simple examples to see how it works

---

## Scope

First, functions have their own **local scope**

--


```julia
ff(xx) = xx^2;
yy = 5;
ff(yy)
```

```
## 25
```

`xx` isn't bound to any values outside the function `ff`
- It is only used inside the function


---
## Scope

Locally scoped functions allow us to do things like:


```julia
xx = 10;
fff(xx) = xx^2;
fff(5)
```

```
## 25
```

--

Although `xx` was declared equal to 10 *outside the function*, the function still evaluated `xx` within its own scope at 5 (the value passed as argument)

---

## Scope

But, this type of scoping also has (initially) counterintuitive results like:


```julia
zz = 0;
for ii = 1:10
  zz = ii
end
println("zz = $zz")
```

```
## zz = 0
```

--

#### What happened?

---

## Scope

#### What happened?

The `zz` *outside* the for loop has a different scope: it's in the **global scope**

--

The global scope is the outermost scope, outside all functions and loops

--

The `zz` *inside* the for loop has a scope *local* to the loop

--

Since the outside `zz` has global scope, the locally scoped variables in the loop can't change it

---

## Scope

Generally, you want to avoid global scope because it can cause conflicts, slowness, etc. But you can use `global` to force it if you want something to have global scope


```julia
zz = 0;
for ii = 1:10
  global zz
  zz = ii
end
println("zz = $zz")
```

```
## zz = 10
```

---

## Scope

Local scope kicks in whenever you have a new block keyword (i.e. you indented something) except for `if`

Global variables inside a local scope are inherited for .blue[reading], not writing


```julia
x, y = 1, 2;
function foo()
  x = 2        # assignment introduces a new local
  return x + y # y refers to the global
end;
foo()
```

```
## 4
```

```julia
x
```

```
## 1
```

---

## Scope

We can fix looping issues with global scope by using a wrapper function that doesn't do anything but change the parent scope so it is not global


```julia
zzz = 1;
function wrapper()
  zzz = 0;
  for iii = 1:10
    zzz = iii
  end
  println("zzz = $zzz")
end
```

```
## wrapper (generic function with 1 method)
```

```julia
wrapper()
```

```
## zzz = 10
```


---

## Generic functions

If you use Julia to write code for research you should aim to write **generic functions**

--

These functions
- are flexible: e.g. can deal with someone using an `Int` instead of a `Float`
- have high performance, speed comparable to C

---

## Generic functions

Functions are made generic by paying attention to types and making sure types are **stable**

--

**Type stability:** Given an input into a function, operations on that input should maintain the type so Julia *knows* what its type will be throughout the full function call

--

This allows Julia to compile type-specialized versions of the functions, which will yield higher performance

--

*Type stability* sounds like mandating types (like what C and Fortran do, unlike what R and Python do). So how do we make it flexible?

---

## Generic functions: type stability

These two functions look the same, but are they?


```julia
function t1(n)
  s = 0
  t = 1
  for i in 1:n
     s += s/i
     t = div(t, i)
  end
  return t
end
```

```julia
function t2(n)
  s  = 0.0
  t = 1
  for i in 1:n
     s += s/i
     t = div(t, i)
  end
  return t
end
```

---

## Generic functions: type stability

No! t1 is *not type stable*

--

`t1` starts with `s` as an `Int64`. But then we have `s += s/i` which means it must hold a `Float64`

--

It must be converted to `Float` so it is not type stable

---

## Generic functions: type stability

We can see this when calling the macro `@code_warntype` where it reports `t1` at some point handles `s` that has type `Union{Float64,Int64}`, either `Float64` or `Int64`

Julia now can't assume `s`'s type and produce pure integer or floating point code. This leads to **performance degradation**

&lt;div align="center"&gt;
  &lt;img src="figures/t1_codewarn.png" height=150&gt;
  &lt;img src="figures/t2_codewarn.png" height=150&gt;
&lt;/div&gt;

---

## Concrete vs abstract types

A **concrete type** is one that can be instantiated 
- E.g.: `Float64`, `Bool`, `Int32`

--

An **abstract type** cannot 
- E.g.: `Real`, `Number`, `Any`

---

## Concrete vs abstract types

Abstract types are used for organizing types

You can check where types are in the hierarchy (with the subtype operator `&lt;:`)


```julia
@show Float64 &lt;: Real
```

```
## Float64 &lt;: Real = true
```

```
## true
```

```julia
@show Array &lt;: Real
```

```
## Array &lt;: Real = false
```

```
## false
```

```julia
@show Number &lt;: Any
```

```
## Number &lt;: Any = true
```

```
## true
```

---

## Concrete vs abstract types

You can see the type hierarchy with the supertypes and subtypes commands


```julia
using Base: show_supertypes
show_supertypes(Float64)
```

```
## Float64 &lt;: AbstractFloat &lt;: Real &lt;: Number &lt;: Any
```

---

## Creating new types

We can actually create new composite types using `struct`

--


```julia
struct FoobarNoType # This will be immutable by default
  a
  b
  c
end
```

This creates a new type called `FoobarNoType`

---

## Creating new types

We can generate a variable of type `FoobarNoType` using its **constructor** which will have the same name

--


```julia
newfoo = FoobarNoType(1.3, 2, "plzzz");
typeof(newfoo)
```

```
## FoobarNoType
```

```julia
newfoo.a
```

```
## 1.3
```

---

## Creating new types

Custom types are a *handy and elegant way of organizing your program*

- You can define a type `ModelParameters` to contain all your model parameters

- Each variable you instantiate represents a single scenario

- Then, instead of having a function call

```
RunMyModel(param1, param2, param3, param4, param5);
```

- You call

```
RunMyModel(modelParameters);
```


---

## Creating new types

.red[You should always declare types for the fields of a new composite type]

--

You can declare types with the double colon



```julia
struct FoobarType # This will be immutable by default
  a::Float64
  b::Int
  c::String
end
```

---

## Creating new types


```julia
newfoo_typed = FoobarType(1.3, 2, "plzzz");
typeof(newfoo_typed)
```

```
## FoobarType
```

```julia
newfoo.a
```

```
## 1.3
```

This lets the compiler generate efficient code because it knows the types of the fields when you construct a `FoobarType`

Declaring abstract types isn't good enough: you need to declare concrete types. But how do we keep it flexible, then?

---

## Creating new types

#### Parametric types are what help deliver flexibility

We can create types that hold different types of fields by declaring subsets of abstract types


```julia
struct FooParam{t1 &lt;: Real, t2 &lt;: Real, t3 &lt;: AbstractArray{&lt;:Real}}
  a::t1
  b::t2
  c::t3
end
newfoo_para = FooParam(1.0, 7, [1., 4., 6.])
```

```
## FooParam{Float64, Int64, Vector{Float64}}(1.0, 7, [1.0, 4.0, 6.0])
```

--

The curly brackets declare all the different type subsets we will use in `FooParam`

--

This actually delivers high-performance code!

---

## Delivering flexibility

We want to make sure types are stable but code is flexible

Ex: if want to preallocate an array to store data,
how do we know how to declare it's type?

--

We don't need to!

---

## Delivering flexibility


```julia
using LinearAlgebra               # necessary for I
function sametypes(x)
  y = similar(x)                  # preallocates an array that is `similar` to x
  z = I                           # creates a scalable identity matrix
  q = ones(eltype(x), length(x))  # one is a type generic array of ones, fill creates the array of length(x)
  y .= z * x + q
  return y
end
```

```
## sametypes (generic function with 1 method)
```

```julia

x = [5.5, 7.0, 3.1];
y = [7, 8, 9];
```

---

## Delivering flexibility

We did not declare any types but the function is type stable



```julia
sametypes(x)
sametypes(y)
```

&lt;div align="center"&gt;
  &lt;img src="figures/generic_codewarn_float.png" height=125&gt;
  &lt;img src="figures/generic_codewarn_int.png" height=125&gt;
&lt;/div&gt;

--

There's a lot of other functions out there that help with writing flexible, type-stable code

---

## Multiple dispatch

#### Why type stability really matters: multiple dispatch

Neat thing about Julia: the same function name can perform different operations depending on the underlying type of the inputs

A function specifies different **methods**, each of which operates on a specific set of types

---

## Multiple dispatch

When you write a function that's type stable, you are actually writing many different methods, each of which are optimized for certain types

--

If your function isn't type stable, the optimized method may not be used

This is why Julia can achieve C speed: it compiles to C (or faster) code

---

## Multiple dispatch

`/` has 103 different methods depending on the input types, these are 103 specialized sets of codes


```julia
methods(/)
```

```
## # 118 methods for generic function "/":
## [1] /(a, b::ChainRulesCore.AbstractThunk) in ChainRulesCore at C:\Users\Diego\.julia\packages\ChainRulesCore\IFusD\src\tangent_types\thunks.jl:33
## [2] /(x::Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}, y::Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}) in Base at int.jl:93
## [3] /(x::Union{Integer, Complex{&lt;:Union{Integer, Rational}}}, y::Rational) in Base at rational.jl:345
## [4] /(x::Union{Int16, Int32, Int8, UInt16, UInt32, UInt8}, y::BigInt) in Base.GMP at gmp.jl:545
## [5] /(c::Union{UInt16, UInt32, UInt8}, x::BigFloat) in Base.MPFR at mpfr.jl:433
## [6] /(c::Union{Int16, Int32, Int8}, x::BigFloat) in Base.MPFR at mpfr.jl:445
## [7] /(c::Union{Float16, Float32, Float64}, x::BigFloat) in Base.MPFR at mpfr.jl:457
## [8] /(A::Union{LinearAlgebra.AbstractTriangular, StridedMatrix}, D::Diagonal) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\diagonal.jl:494
## [9] /(X::StridedArray{P}, y::P) where P&lt;:Dates.Period in Dates at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\Dates\src\deprecated.jl:44
## [10] /(X::StridedArray{P}, y::Real) where P&lt;:Dates.Period in Dates at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\Dates\src\deprecated.jl:44
## [11] /(x::Union{SparseArrays.SparseVector{Tv, Ti}, SubArray{Tv, 1, &lt;:SparseArrays.AbstractSparseVector{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Int64}}}, false}, SubArray{Tv, 1, &lt;:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, false}} where {Tv, Ti}, a::Number) in SparseArrays at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\SparseArrays\src\sparsevector.jl:1476
## [12] /(A::Tridiagonal, B::Number) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\tridiag.jl:744
## [13] /(z::Complex, x::Real) in Base at complex.jl:346
## [14] /(A::SparseArrays.AbstractSparseMatrixCSC, D::Diagonal) in SparseArrays at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\SparseArrays\src\linalg.jl:152
## [15] /(D::Diagonal, x::Number) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\diagonal.jl:192
## [16] /(Da::Diagonal, Db::Diagonal) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\diagonal.jl:451
## [17] /(u::Adjoint{T, &lt;:AbstractVector} where T, A::Transpose{&lt;:Any, &lt;:AbstractMatrix}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\adjtrans.jl:322
## [18] /(u::Adjoint{T, &lt;:AbstractVector} where T, A::Union{LowerTriangular, UpperTriangular}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:2576
## [19] /(u::Adjoint{T, &lt;:AbstractVector} where T, A::Union{UnitLowerTriangular, UnitUpperTriangular}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:2577
## [20] /(B::Adjoint{T, &lt;:AbstractVector} where T, F::Transpose{&lt;:Any, &lt;:Factorization{&lt;:Real}}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\factorization.jl:140
## [21] /(B::Adjoint{T, &lt;:AbstractVector} where T, F::Transpose{&lt;:Any, &lt;:Factorization}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\factorization.jl:142
## [22] /(adjA::Adjoint{&lt;:Any, &lt;:AbstractVector}, F::Adjoint{&lt;:Any, &lt;:LU}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\lu.jl:441
## [23] /(adjB::Adjoint{T, &lt;:AbstractVector} where T, adjF::Adjoint{&lt;:Any, &lt;:Factorization}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\factorization.jl:117
## [24] /(u::Adjoint{T, &lt;:AbstractVector} where T, A::AbstractMatrix) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\adjtrans.jl:320
## [25] /(adjA::Adjoint{&lt;:Any, &lt;:AbstractMatrix}, F::Adjoint{&lt;:Any, &lt;:LU}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\lu.jl:442
## [26] /(x::P, y::P) where P&lt;:Dates.Period in Dates at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\Dates\src\periods.jl:82
## [27] /(x::P, y::Real) where P&lt;:Dates.Period in Dates at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\Dates\src\periods.jl:83
## [28] /(J1::UniformScaling, J2::UniformScaling) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\uniformscaling.jl:267
## [29] /(J::UniformScaling, A::AbstractMatrix) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\uniformscaling.jl:268
## [30] /(J::UniformScaling, x::Number) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\uniformscaling.jl:273
## [31] /(A::LowerTriangular, x::Number) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:869
## [32] /(A::LowerTriangular, B::LowerTriangular) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:1572
## [33] /(A::LowerTriangular, B::UnitLowerTriangular) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:1586
## [34] /(A::SymTridiagonal, B::Number) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\tridiag.jl:213
## [35] /(x::Rational, y::Union{Integer, Complex{&lt;:Union{Integer, Rational}}, Rational}) in Base at rational.jl:344
## [36] /(a::R, z::S) where {R&lt;:Real, S&lt;:Complex} in Base at complex.jl:345
## [37] /(x::RObject, y::RObject) in RCall at C:\Users\Diego\.julia\packages\RCall\iMDW2\src\operators.jl:6
## [38] /(x::Number, B::BitArray) in Base at bitarray.jl:1201
## [39] /(::Number, ::Missing) in Base at missing.jl:124
## [40] /(x::Number, v::AbstractVector) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\generic.jl:1154
## [41] /(A::UnitUpperTriangular, x::Number) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:871
## [42] /(A::UnitUpperTriangular, B::UpperTriangular) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:1607
## [43] /(A::UnitUpperTriangular, B::UnitUpperTriangular) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:1621
## [44] /(u::Transpose{T, &lt;:AbstractVector} where T, A::UnitUpperTriangular{&lt;:Any, &lt;:Transpose}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:2587
## [45] /(u::Transpose{T, &lt;:AbstractVector} where T, A::UnitUpperTriangular{&lt;:Any, &lt;:Adjoint}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:2586
## [46] /(u::Transpose{T, &lt;:AbstractVector} where T, A::UnitLowerTriangular{&lt;:Any, &lt;:Transpose}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:2587
## [47] /(u::Transpose{T, &lt;:AbstractVector} where T, A::UnitLowerTriangular{&lt;:Any, &lt;:Adjoint}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:2586
## [48] /(u::Transpose{T, &lt;:AbstractVector} where T, A::Union{UnitLowerTriangular, UnitUpperTriangular}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:2580
## [49] /(u::Transpose{T, &lt;:AbstractVector} where T, A::UpperTriangular{&lt;:Any, &lt;:Transpose}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:2587
## [50] /(u::Transpose{T, &lt;:AbstractVector} where T, A::UpperTriangular{&lt;:Any, &lt;:Adjoint}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:2586
## [51] /(B::Transpose{T, &lt;:AbstractVector} where T, F::Transpose{&lt;:Any, &lt;:Factorization{&lt;:Real}}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\factorization.jl:141
## [52] /(B::AbstractMatrix, F::Transpose{&lt;:Any, &lt;:Factorization{&lt;:Real}}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\factorization.jl:138
## [53] /(B::Transpose{T, &lt;:AbstractVector} where T, F::Transpose{&lt;:Any, &lt;:Factorization}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\factorization.jl:143
## [54] /(B::AbstractMatrix, F::Transpose{&lt;:Any, &lt;:Factorization}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\factorization.jl:139
## [55] /(u::Transpose{T, &lt;:AbstractVector} where T, A::Adjoint{&lt;:Any, &lt;:AbstractMatrix}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\adjtrans.jl:323
## [56] /(trA::Transpose{&lt;:Any, &lt;:AbstractVector}, F::Adjoint{&lt;:Any, &lt;:LU}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\lu.jl:443
## [57] /(B::Transpose{T, &lt;:AbstractVector} where T, adjF::Adjoint{&lt;:Any, &lt;:Factorization}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\factorization.jl:118
## [58] /(trA::Transpose{&lt;:Any, &lt;:AbstractMatrix}, F::Adjoint{&lt;:Any, &lt;:LU}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\lu.jl:447
## [59] /(A::AbstractMatrix, F::Adjoint{&lt;:Any, &lt;:LU}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\lu.jl:436
## [60] /(u::Transpose{T, &lt;:AbstractVector} where T, A::LowerTriangular{&lt;:Any, &lt;:Transpose}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:2587
## [61] /(u::Transpose{T, &lt;:AbstractVector} where T, A::LowerTriangular{&lt;:Any, &lt;:Adjoint}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:2586
## [62] /(u::Transpose{T, &lt;:AbstractVector} where T, A::Union{LowerTriangular, UpperTriangular}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:2579
## [63] /(u::Transpose{T, &lt;:AbstractVector} where T, A::AbstractMatrix) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\adjtrans.jl:321
## [64] /(a::ChainRulesCore.AbstractThunk, b) in ChainRulesCore at C:\Users\Diego\.julia\packages\ChainRulesCore\IFusD\src\tangent_types\thunks.jl:32
## [65] /(z::ChainRulesCore.AbstractZero, ::Any) in ChainRulesCore at C:\Users\Diego\.julia\packages\ChainRulesCore\IFusD\src\tangent_types\abstract_zero.jl:25
## [66] /(A::Union{BitMatrix, BitVector}, B::Union{BitMatrix, BitVector}) in Base at bitarray.jl:1197
## [67] /(B::BitArray, x::Number) in Base at bitarray.jl:1200
## [68] /(r::AbstractRange{&lt;:P}, x::P) where P&lt;:Dates.Period in Dates at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\Dates\src\ranges.jl:67
## [69] /(x::AbstractIrrational, y::AbstractIrrational) in Base at irrationals.jl:158
## [70] /(H::UpperHessenberg, x::Number) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\hessenberg.jl:116
## [71] /(H::UpperHessenberg, x::UniformScaling) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\hessenberg.jl:116
## [72] /(A::AbstractMatrix, J::UniformScaling) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\uniformscaling.jl:270
## [73] /(v::AbstractVector, J::UniformScaling) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\uniformscaling.jl:271
## [74] /(H::UpperHessenberg, x::Diagonal) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\hessenberg.jl:116
## [75] /(H::UpperHessenberg, U::UpperTriangular) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\hessenberg.jl:136
## [76] /(H::UpperHessenberg, U::UnitUpperTriangular) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\hessenberg.jl:143
## [77] /(H::UpperHessenberg, B::Bidiagonal) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\hessenberg.jl:183
## [78] /(A::Hermitian, x::Real) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\symmetric.jl:639
## [79] /(A::Symmetric, x::Number) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\symmetric.jl:638
## [80] /(A::UpperTriangular, x::Number) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:869
## [81] /(A::UpperTriangular, B::UpperTriangular) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:1600
## [82] /(A::UpperTriangular, B::UnitUpperTriangular) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:1614
## [83] /(x::Base.TwicePrecision, v::Number) in Base at twiceprecision.jl:315
## [84] /(x::Base.TwicePrecision, y::Base.TwicePrecision) in Base at twiceprecision.jl:319
## [85] /(r::StepRangeLen{&lt;:Real, &lt;:Base.TwicePrecision}, x::Real) in Base at twiceprecision.jl:524
## [86] /(A::Bidiagonal, B::Number) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\bidiag.jl:375
## [87] /(B::Union{Array{Complex{T}, 1}, Array{Complex{T}, 2}}, F::Factorization{T}) where T&lt;:Union{Float32, Float64} in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\factorization.jl:96
## [88] /(B::AbstractMatrix, F::Union{Adjoint{&lt;:Any, &lt;:Factorization}, Factorization}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\factorization.jl:110
## [89] /(A::UnitLowerTriangular, x::Number) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:871
## [90] /(A::AbstractArray, B::Number) in Base at arraymath.jl:55
## [91] /(A::UnitLowerTriangular, B::LowerTriangular) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:1579
## [92] /(A::AbstractVector, B::Union{LowerTriangular, UpperTriangular}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:1672
## [93] /(A::AbstractMatrix, B::Union{LowerTriangular, UpperTriangular}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:1672
## [94] /(A::UnitLowerTriangular, B::UnitLowerTriangular) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:1593
## [95] /(A::AbstractVector, B::Union{UnitLowerTriangular, UnitUpperTriangular}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:1664
## [96] /(A::AbstractMatrix, B::Union{UnitLowerTriangular, UnitUpperTriangular}) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\triangular.jl:1664
## [97] /(A::AbstractVecOrMat, B::AbstractVecOrMat) in LinearAlgebra at C:\PROGRA~1\JULIA-~1.1\share\julia\stdlib\v1.7\LinearAlgebra\src\generic.jl:1148
## [98] /(x::Float16, y::Float16) in Base at float.jl:406
## [99] /(x::Float64, y::Float64) in Base at float.jl:408
## [100] /(x::BigFloat, c::Union{UInt16, UInt32, UInt8}) in Base.MPFR at mpfr.jl:428
## [101] /(x::BigFloat, c::Union{Int16, Int32, Int8}) in Base.MPFR at mpfr.jl:440
## [102] /(x::BigFloat, c::Union{Float16, Float32, Float64}) in Base.MPFR at mpfr.jl:452
## [103] /(x::BigFloat, y::BigFloat) in Base.MPFR at mpfr.jl:421
## [104] /(x::BigFloat, c::BigInt) in Base.MPFR at mpfr.jl:464
## [105] /(z::ComplexF64, w::ComplexF64) in Base at complex.jl:381
## [106] /(z::Complex{T}, w::Complex{T}) where T&lt;:Union{Float16, Float32} in Base at complex.jl:372
## [107] /(a::Complex{T}, b::Complex{T}) where T&lt;:Real in Base at complex.jl:348
## [108] /(x::Float32, y::Float32) in Base at float.jl:407
## [109] /(x::ChainRulesCore.NotImplemented, ::ChainRulesCore.NotImplemented) in ChainRulesCore at C:\Users\Diego\.julia\packages\ChainRulesCore\IFusD\src\tangent_types\notimplemented.jl:44
## [110] /(::Any, x::ChainRulesCore.NotImplemented) in ChainRulesCore at C:\Users\Diego\.julia\packages\ChainRulesCore\IFusD\src\tangent_types\notimplemented.jl:43
## [111] /(x::ChainRulesCore.NotImplemented, ::Any) in ChainRulesCore at C:\Users\Diego\.julia\packages\ChainRulesCore\IFusD\src\tangent_types\notimplemented.jl:42
## [112] /(x::BigInt, y::Union{Int16, Int32, Int8, UInt16, UInt32, UInt8}) in Base.GMP at gmp.jl:544
## [113] /(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:495
## [114] /(x::T, y::T) where T&lt;:Integer in Base at int.jl:91
## [115] /(x::T, y::T) where T&lt;:Number in Base at promotion.jl:457
## [116] /(x::Number, y::Number) in Base at promotion.jl:382
## [117] /(::Missing, ::Number) in Base at missing.jl:123
## [118] /(::Missing, ::Missing) in Base at missing.jl:122
```


---

## More on coding practices and efficiency

See [JuliaPraxis](https://github.com/JuliaPraxis) for best practices for naming, spacing, comments, etc

See more [Performance tips](https://docs.julialang.org/en/v1/manual/performance-tips) from Julia Documentation


---

## .blue[Course roadmap]

This concludes Unit 1. Up next

1. .gray[Intro to Scientific Computing]
2. **Numerical operations and representations** 
   1. **Numerical arithmetic** `\(\leftarrow\)`
   2. .gold[Numerical differentiation and integration]
   3. .gold[Function approximation]
3. Systems of equations
4. Optimization
5. Structural estimation

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
