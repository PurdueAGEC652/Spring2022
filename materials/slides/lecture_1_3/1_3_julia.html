<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>AGEC 652 - Lecture 1.3</title>
    <meta charset="utf-8" />
    <meta name="author" content="Diego S. Cardoso" />
    <script src="1_3_julia_files/header-attrs-2.11/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# AGEC 652 - Lecture 1.3
## An introduction to Julia
### Diego S. Cardoso
### Spring 2022

---

exclude: true

```r
if (!require("pacman")) install.packages("pacman")
```

```
## Loading required package: pacman
```

```r
pacman::p_load(
  xaringanthemer, JuliaCall
)

#options(htmltools.dir.version = FALSE)

knitr::opts_hooks$set(fig.callout = function(options) {
  if (options$fig.callout) {
    options$echo &lt;- FALSE
  }

  knitr::opts_chunk$set(echo = TRUE, fig.align="center")
  options
})
```




```julia
using Pkg
Pkg.activate(".")
Pkg.instantiate()
Pkg.add("BenchmarkTools")
```



---

## Software requirements

By now you hopefully have installed
- Julia

- Visual Studio Code with Julia extension
- Jupyter
  - We will take a quick look on how to use VS Code and Jupyter at the end of this unit


---

class: inverse, center, middle

# Programming with Julia

.footnote[\*These slides are based on Software Carpentry, notes by Ivan Rudik and Grant Mcdermott, QuantEcon, and Julia documentation.]

---

## Why learn Julia?

1. It's a high-level language: much easier to learn and use than C++ and Fortran
2. It delivers C++ and Fortran speed

&lt;div align="center"&gt;
  &lt;img src="figures/julia_speed_2.png" height=320&gt;
&lt;/div&gt;
.center[.footnote[*In this graph, time to execute in C++ is 1]]

---

## Intro to programming

### Programming `\(\equiv\)` writing a set of instructions

- There are hard rules you can't break if you want your code to work

--

- There are elements of style (e.g. Strunk and White) that make your code easier to read, modify, and maintain

--

- There are elements that make your code more efficient
  - Using less time or space (memory)


---

## Intro to programming

If you will be doing computational work there are:

1. Language-independent coding basics you should know
    - Arrays are stored in memory in particular ways
2. Language-independent best practices you should use
    - Indent to convey program structure (or function in Python)
3. Language-dependent idiosyncracies that matter for function, speed, etc
    - Julia: type stability; R: vectorize

---

## Intro to programming

Learning these early will:

1. Make coding a lot easier
--

2. Reduce total programmer time
--

3. Reduce total computer time
--

4. Make your code understandable by someone else or your future self
--

5. Make your code flexible

---

## A broad view of programming

Your goal is to make a **program**

A program is made of different components and sub-components

--

The most basic component is a **statement**, more commonly called a **line of code**


---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
*deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:

1. Create a deck of cards

---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
*shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:
1. Create a deck of cards
2. Shuffle the deck

---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
*first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:
1. Create a deck of cards
2. Shuffle the deck
3. Draw the top card

---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
*println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:
1. Create a deck of cards
2. Shuffle the deck
3. Draw the top card
4. Print it

---

## A broad view of programming

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

What are the parentheses and why are they different from square brackets?

How does shuffle work?

What’s `println`?

It’s important to know that a **good program has understandable code**

---

## Julia specifics

We will discuss coding in the context of Julia
but a lot of this ports to Python, MATLAB, etc&lt;sup&gt;1&lt;/sup&gt;

We will review

1. Types
2. Operators
3. Scope
4. Generic functions
5. Multiple dispatch


.footnote[&lt;sup&gt;1&lt;/sup&gt;See [https://cheatsheets.quantecon.org](https://cheatsheets.quantecon.org)]

&lt;!-- --- --&gt;

&lt;!-- # Types --&gt;

&lt;!-- All languages have some kind of **data types** like integers or arrays --&gt;

&lt;!-- -- --&gt;

&lt;!-- The first type you will often use is a boolean (`Bool`) variable that takes on a value of `true` or `false`: --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- x = true --&gt;
&lt;!-- typeof(x) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Types --&gt;

&lt;!-- We can save the boolean value of actual statements in variables this way: --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- @show y = 1 &gt; 2 --&gt;
&lt;!-- ``` --&gt;

&lt;!-- `@show` is a Julia macro for showing the operation --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Numbers --&gt;

&lt;!-- Two other data types you will use frequently are integers --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- typeof(1) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- and floating point numbers --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- typeof(1.0) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- Recall from lecture 1 the 64 means 64 bits of storage for the number, which is probably the default on your machine --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Numbers --&gt;

&lt;!-- You can always instantiate alternative floating point number types --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- converted_int = convert(Float32, 1.0); --&gt;
&lt;!-- typeof(converted_int) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Numbers --&gt;

&lt;!-- ### Math works like you would expect: --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- a = 2; b = 1.0; --&gt;
&lt;!-- a * b --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- a^2 --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Numbers --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- 2a - 4b --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- @show 4a + 3b^2 --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- You dont need `*` inbetween numeric literals (numbers) and variables --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Strings --&gt;

&lt;!-- Strings store sequences of characters --&gt;

&lt;!-- -- --&gt;

&lt;!-- You implement them with double quotations: --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- x = "Hello World!"; --&gt;
&lt;!-- typeof(x) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- Note that `;` suppresses output for that line of code but is unnecessary in Julia --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Strings --&gt;

&lt;!-- It's easy to work with strings, use `$` to interpolate a variable/expression --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- x = 10; y = 20; println("x + y =  $(x+y).") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- Use `*` to concatenate strings --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- a = "Aww"; b = "Yeah!!!"; println(a * " " * b) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- You probably won't use strings too often unless you're working with text data or printing output --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Containers --&gt;

&lt;!-- Containers are types that store collections of data --&gt;

&lt;!-- -- --&gt;

&lt;!-- The most basic container is the `Array` which is denoted by square brackets --&gt;

&lt;!-- -- --&gt;


&lt;!-- ```{julia} --&gt;
&lt;!-- a1 = [1 2; 3 4]; typeof(a1) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- Arrays are **mutable** which means you can change their values --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- a1[1,1] = 5; a1 --&gt;
&lt;!-- ``` --&gt;

&lt;!-- You reference elements in a container with square brackets --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Containers --&gt;

&lt;!-- An alternative to the `Array` is the `Tuple` which is denoted by parentheses --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- a2 = (1, 2, 3, 4); typeof(a2) --&gt;
&lt;!-- ``` --&gt;
&lt;!-- `a2` is a `Tuple` of 4 `Int64`s, tuples have no dimension --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Containers --&gt;

&lt;!-- Tuples are **immutable** which means you **can't** change their values --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- try --&gt;
&lt;!--   a2[1,1] = 5; --&gt;
&lt;!-- catch --&gt;
&lt;!--   println("Error, can't change value of a tuple.") --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Containers --&gt;

&lt;!-- Tuples don't need parentheses (but it's probably best practice for clarity) --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- a3 = 5, 6; typeof(a3) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Containers --&gt;

&lt;!-- Tuples can be **unpacked** (see [`NamedTuple`](https://docs.julialang.org/en/v1/manual/types/#Named-Tuple-Types-1) for an alternative and more efficient container) --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- a3_x, a3_y = a3; --&gt;
&lt;!-- a3_x --&gt;
&lt;!-- a3_y --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- This is basically how functions return output when you call them --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Containers --&gt;

&lt;!-- A `Dictionary` is the last main container type, --&gt;
&lt;!-- they are arrays but are indexed by keys (names) instead of numbers --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- d1 = Dict("class" =&gt; "AEM7130", "grade" =&gt; 97); --&gt;
&lt;!-- typeof(d1) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- `d1` is a dictionary where the key are strings and the values are any kind of type --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Containers --&gt;

&lt;!-- Reference specific values you want in the dictionary by referencing the key --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- d1["class"] --&gt;
&lt;!-- d1["grade"] --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Containers --&gt;

&lt;!-- If you just want all the keys or all the values you can use the base functions --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- keys_d1 = keys(d1) --&gt;
&lt;!-- values_d1 = values(d1) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Iterating --&gt;

&lt;!-- As in other languages we have loops at our disposal: --&gt;

&lt;!-- `for` loops iterate over containers --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- for count in 1:10 --&gt;
&lt;!--   random_number = rand() --&gt;
&lt;!--   if random_number &gt; 0.2 --&gt;
&lt;!--     println("We drew a $random_number.") --&gt;
&lt;!--   end --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Iterating --&gt;

&lt;!-- `while` loops iterate until a logical expression is false --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- while rand() &gt; 0.5 --&gt;
&lt;!--   random_number = rand() --&gt;
&lt;!--   if random_number &gt; 0.2 --&gt;
&lt;!--     println("We drew a $random_number.") --&gt;
&lt;!--   end --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Iterating --&gt;

&lt;!-- An `Iterable` is something you can loop over, like arrays --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- actions = ["codes well", "skips class"]; --&gt;
&lt;!-- for action in actions --&gt;
&lt;!--     println("Charlie $action") --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Iterating --&gt;

&lt;!-- There's a type that's a subset of iterables, `Iterator`, that are particularly convenient --&gt;

&lt;!-- -- --&gt;

&lt;!-- These include things like the dictionary keys: --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- for key in keys(d1) --&gt;
&lt;!--   println(d1[key]) --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Iterating --&gt;

&lt;!-- Iterating on `Iterator`s is more memory efficient than iterating on arrays --&gt;

&lt;!-- -- --&gt;

&lt;!-- Here's a **very** simple example, the top function iterates on an `Array`, the bottom function iterates on an `Iterator`: --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- function show_array_speed() --&gt;
&lt;!--   m = 1 --&gt;
&lt;!--   for i = [1, 2, 3, 4, 5, 6] --&gt;
&lt;!--     m = m*i --&gt;
&lt;!--   end --&gt;
&lt;!-- end; --&gt;

&lt;!-- function show_iterator_speed() --&gt;
&lt;!--   m = 1 --&gt;
&lt;!--   for i = 1:6 --&gt;
&lt;!--     m = m*i --&gt;
&lt;!--   end --&gt;
&lt;!-- end; --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Iterating --&gt;


&lt;!-- ```{julia} --&gt;
&lt;!-- using BenchmarkTools --&gt;
&lt;!-- @btime show_array_speed() --&gt;
&lt;!-- @btime show_iterator_speed() --&gt;
&lt;!-- ``` --&gt;

&lt;!-- The `Iterator` approach is faster and allocates no memory --&gt;

&lt;!-- `@btime` is a macro from `BenchmarkTools` that shows you the elasped time and memory allocation --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Neat looping --&gt;

&lt;!-- The nice thing about Julia vs MATLAB is your loops can be much neater since you don't need to index if you just want the container elements --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- f(x) = x^2; --&gt;
&lt;!-- x_values = 0:20:100; --&gt;
&lt;!-- for x in x_values --&gt;
&lt;!--   println(f(x)) --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Neat looping --&gt;

&lt;!-- The loop directly assigns the elements of `x_values` to `x` instead of having to do something clumsy like `x_values[i]` --&gt;

&lt;!-- -- --&gt;

&lt;!-- `0:20:100` creates something called a `StepRange` (a type of `Iterator`) which starts at `0`, steps up by `20` and ends at `100` --&gt;


&lt;!-- --- --&gt;

&lt;!-- # Neat looping --&gt;

&lt;!-- You can also pull out an index and the element value by enumerating --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- f(x) = x^2; --&gt;
&lt;!-- x_values = 0:20:100; --&gt;
&lt;!-- for (index, x) in enumerate(x_values) --&gt;
&lt;!--   println("f(x) at value $index is $(f(x)).") --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- `enumerate` basically assigns an index vector --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Neat looping --&gt;

&lt;!-- There is also a lot of Python-esque functionality --&gt;

&lt;!-- -- --&gt;

&lt;!-- For example: `zip` lets you loop over multiple different iterables at once --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- last_name = ("Lincoln", "Bond", "Walras"); --&gt;
&lt;!-- first_name = ("Abraham", "James", "Leon"); --&gt;

&lt;!-- for (first_idx, last_idx) in zip(first_name, last_name) --&gt;
&lt;!--   println("The name's $last_idx, $first_idx $last_idx.") --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Neat looping --&gt;

&lt;!-- Nested loops can also be made very neatly --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- for x in 1:3, y in 3:-1:1 --&gt;
&lt;!--   println(y-x) --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- The first loop is the inner loop, the second loop is the outer loop --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Comprehensions: the neatest looping --&gt;

&lt;!-- Comprehensions are super nice ways to use iterables that make your code cleaner and more compact --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- squared = [y^2 for y in 1:2:11] --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- This created a 1-dimension `Array` using one line --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Comprehensions: the neatest looping --&gt;

&lt;!-- We can also use nested loops for comprehensions --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- squared_2 = [(y+z)^2 for y in 1:2:11, z in 1:6] --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- This created a 2-dimensional `Array` --&gt;

&lt;!-- -- --&gt;

&lt;!-- Use this (and the compact nested loop) sparingly since it's hard to follow --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Dot syntax: broadcasting/vectorization --&gt;

&lt;!-- Vectorizing operations (e.g. applying it to a whole array or vector at once) is easy in Julia, just use dot syntax like you would in MATLAB, etc --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- g(x) = x^2; --&gt;
&lt;!-- squared_2 = g.(1:2:11) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- This is actually called **broadcasting** --&gt;

&lt;!-- -- --&gt;

&lt;!-- When broadcasting, you might want to consider **pre-allocating** arrays --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Dot syntax: broadcasting/vectorization --&gt;

&lt;!-- Vectorization creates *temporary allocations*, temporary arrays in the middle of the process that aren't actually needed for the final product --&gt;

&lt;!-- Julia can do broadcasting in a nicer, faster way by .hi-blue[fusing] operations together and avoiding these temporary allocations --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Dot syntax: broadcasting/vectorization --&gt;

&lt;!-- Let's write two functions that do the same thing: --&gt;

&lt;!-- ```{julia, results = 'hide'} --&gt;
&lt;!-- function show_vec_speed(x) --&gt;
&lt;!--   out = [3x.^2 + 4x + 7x.^3 for i = 1:1] --&gt;
&lt;!-- end --&gt;
&lt;!-- function show_fuse_speed(x) --&gt;
&lt;!--   out = @. [3x.^2 + 4x + 7x.^3 for i = 1:1] --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- The top one is vectorized for the operations, the `@.` in the bottom one vectorizes everything in one swoop: the function call, the operation, and the assignment to a variable --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Dot syntax: broadcasting/vectorization --&gt;

&lt;!-- First, precompile the functions --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- x = rand(10^6); --&gt;
&lt;!-- @time show_vec_speed(x); --&gt;
&lt;!-- @time show_fuse_speed(x); --&gt;
&lt;!-- ``` --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- @time show_vec_speed(x) --&gt;
&lt;!-- @time show_fuse_speed(x) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Full vectorization using `@.` is 10x faster with 1/6 of the memory allocation --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Dot syntax: vectorization --&gt;

&lt;!-- Not pre-allocated: --&gt;

&lt;!-- ```{julia, results = 'hide'} --&gt;
&lt;!-- h(y,z) = y^2 + sin(z);   # function to evaluate --&gt;
&lt;!-- y = 1:2:1e6+1;           # input y --&gt;
&lt;!-- z = rand(length(y));     # input z --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Dot syntax --&gt;

&lt;!-- Here we are vectorizing the function call --&gt;

&lt;!-- ```{julia, results = 'hide'} --&gt;
&lt;!-- # precompile h so first timer isn't picking up on compile time --&gt;
&lt;!-- h(1,2) --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- @time out_1 = h.(y,z)    # evaluate h.(y,z) and time --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- # Dot syntax: vectorization --&gt;

&lt;!-- Here we are vectorizing the function call and assignment --&gt;

&lt;!-- ```{julia, results = 'hide'} --&gt;
&lt;!-- out_2 = similar(out_1) --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- @time out_2 .= h.(y,z) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- # Dot syntax: vectorization --&gt;

&lt;!-- Here we are vectorizing the function call, assignment, and operations --&gt;

&lt;!-- ```{julia, results = 'hide'} --&gt;
&lt;!-- out_3 = similar(out_1) --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- @time @. out_3 = h(y,z) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- # Logical operators work like you'd think --&gt;

&lt;!-- - `==` (equal equal) tests for equality --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- 1 == 1 --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- - `!=` (exclaimation point equal) tests for inequality --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- 2 != 2 --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- - You can also test for approximate equality with `\(\approx\)` (type `\approx&lt;TAB&gt;`) --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- 1.00000001 ≈ 1 --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;


&lt;!-- The .hi-blue[scope] of a variable name determines when it is valid to refer to it --&gt;

&lt;!-- -- --&gt;

&lt;!-- Scope can be a frustrating concept --&gt;

&lt;!-- -- --&gt;

&lt;!-- If you want to dive into the details: the type of scoping in Julia is called **lexical scoping** --&gt;

&lt;!-- -- --&gt;

&lt;!-- Different scopes can have the same name, i.e. `saving_rate`, but be assigned to different variables --&gt;

&lt;!-- -- --&gt;

&lt;!-- Let's walk through some simple examples to see how it works --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- First, functions have their own local scope --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- ff(xx) = xx^2; --&gt;
&lt;!-- yy = 5; --&gt;
&lt;!-- ff(yy) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- `xx` isn't bound to any values outside the function `ff` --&gt;

&lt;!-- This is pretty natural for those of you who have done any programming before --&gt;

&lt;!-- --- --&gt;
&lt;!-- # Scope --&gt;

&lt;!-- Locally scoped functions allow us to do things like: --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- xx = 10; --&gt;
&lt;!-- fff(xx) = xx^2; --&gt;
&lt;!-- fff(5) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Although `xx` was declared equal to 10, the function still evaluated at 5 --&gt;

&lt;!-- -- --&gt;

&lt;!-- This is all kind of obvious so far --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- But, this type of scoping also has (initially) counterintuitive results like: --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- zz = 0; --&gt;
&lt;!-- for ii = 1:10 --&gt;
&lt;!--   zz = ii --&gt;
&lt;!-- end --&gt;
&lt;!-- println("zz = $zz") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- What happened? --&gt;

&lt;!-- -- --&gt;

&lt;!-- The `zz` outside the for loop has a different scope, --&gt;
&lt;!-- the .hi-blue[global scope], than the `zz` inside it --&gt;

&lt;!-- -- --&gt;

&lt;!-- The global scope is the outer most scope, outside all functions and loops --&gt;

&lt;!-- -- --&gt;

&lt;!-- The `zz` inside the for loop has a scope .hi-blue[local] to the loop --&gt;

&lt;!-- -- --&gt;

&lt;!-- Since the outside `zz` has global scope the locally scoped variables in the loop can't change it --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- Generally you want to avoid global scope because it can cause conflicts, slowness, etc, but you can use `global` to force it if you want something to have global scope --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- zz = 0; --&gt;
&lt;!-- for ii = 1:10 --&gt;
&lt;!--   global zz --&gt;
&lt;!--   zz = ii --&gt;
&lt;!-- end --&gt;
&lt;!-- println("zz = $zz") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- Local scope kicks in whenever you have a new block keyword (i.e. you indented something) except for `if` --&gt;

&lt;!-- Global variables inside a local scope are inherted for .hi-blue[reading], not writing --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- x, y = 1, 2; --&gt;
&lt;!-- function foo() --&gt;
&lt;!--   x = 2        # assignment introduces a new local --&gt;
&lt;!--   return x + y # y refers to the global --&gt;
&lt;!-- end; --&gt;
&lt;!-- foo() --&gt;
&lt;!-- x --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- Important piece: nested functions can modify their parent scope's .hi-blue[local] variables --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia, results = 'hide'} --&gt;
&lt;!-- x, y = 1, 2; # set globals --&gt;

&lt;!-- function f_outer() --&gt;
&lt;!--   x = 2                # introduces a new local --&gt;
&lt;!--   function f_inner() --&gt;
&lt;!--     x = 10             # modifies the parent's x --&gt;
&lt;!--     return x + y       # y is global --&gt;
&lt;!--   end --&gt;
&lt;!--   return f_inner() + x # 12 + 10 (x is modified in call of f_inner()) --&gt;
&lt;!-- end; --&gt;
&lt;!-- f_outer() --&gt;
&lt;!-- x, y                   # verify that global x and y are unchanged --&gt;
&lt;!-- ``` --&gt;
&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- function f_outer() --&gt;
&lt;!--   x = 2                # introduces a new local --&gt;
&lt;!--   function f_inner() --&gt;
&lt;!--     x = 10             # modifies the parent's x --&gt;
&lt;!--     return x + y       # y is global --&gt;
&lt;!--   end --&gt;
&lt;!--   return f_inner() + x # 12 + 10 (x is modified in call of f_inner()) --&gt;
&lt;!-- end; --&gt;
&lt;!-- f_outer() --&gt;
&lt;!-- x, y                   # verify that global x and y are unchanged --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- If `f_inner` was not nested and was in the global scope we'd get `14` not `22`, this is also a way to handle the issue with loops editing variables not created in their local scope --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- We can fix looping issues with global scope by using a wrapper function that doesn't do anything but change the parent scope so it is not global --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- function wrapper() --&gt;
&lt;!--   zzz = 0; --&gt;
&lt;!--   for iii = 1:10 --&gt;
&lt;!--     zzz = iii --&gt;
&lt;!--   end --&gt;
&lt;!--   println("zzz = $zzz") --&gt;
&lt;!-- end --&gt;
&lt;!-- wrapper() --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Closures --&gt;

&lt;!-- These inner functions we've been looking at are called .hi-blue[closures] --&gt;

&lt;!-- When a function `f` is parsed in Julia, it looks to see if any of the variables have been previously defined in the current scope --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- a = 0.2; --&gt;
&lt;!-- f(x) = a * x^2;    # refers to the `a` in the outer scope --&gt;
&lt;!-- f(1)               # univariate function --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Closures --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- function g(a) --&gt;
&lt;!--     f(x) = a * x^2; # refers to the `a` passed in the function --&gt;
&lt;!--     f(1);           # univariate function --&gt;
&lt;!-- end --&gt;
&lt;!-- g(0.2) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- In both of these examples `f` is a closure designed to .hi-blue[capture] a variable from an outer scope --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Closures --&gt;

&lt;!-- Here's a complicated example that actually returns a closure (a function!) itself: --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Closures --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- x = 0; --&gt;
&lt;!-- function toplevel(y) --&gt;
&lt;!--   println("x = ", x, " is a global variable") --&gt;
&lt;!--   println("y = ", y, " is a parameter") --&gt;
&lt;!--   z = 2 --&gt;
&lt;!--   println("z = ", z, " is a local variable") --&gt;

&lt;!--   function closure(v) --&gt;
&lt;!--     println("v = ", v, " is a parameter") --&gt;
&lt;!--     w = 3 --&gt;
&lt;!--     println("w = ", w, " is a local variable") --&gt;
&lt;!--     println("x = ", x, " is a global variable") --&gt;
&lt;!--     println("y = ", y, " is a closed variable (a parameter of the outer function)") --&gt;
&lt;!--     println("z = ", z, " is a closed variable (a local of the outer function)") --&gt;
&lt;!--   end; --&gt;
&lt;!--   return closure --&gt;
&lt;!-- end; --&gt;
&lt;!-- ``` --&gt;
&lt;!-- What will be returned when we call these functions? --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Closures --&gt;

&lt;!-- Here's a complicated example: --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- c_func = toplevel(10) --&gt;
&lt;!-- c_func(20) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- The returned closure still has access to the outer function's local scope! --&gt;



&lt;!-- --- --&gt;

&lt;!-- # Generic functions --&gt;

&lt;!-- If you use Julia to write code for research you should aim to write .hi-blue[generic functions] --&gt;

&lt;!-- -- --&gt;

&lt;!-- These are functions that are flexible (e.g. can deal with someone using an `Int` instead of a `Float`) --&gt;
&lt;!-- and have high performance (e.g. comparable speed to C) --&gt;

&lt;!-- -- --&gt;

&lt;!-- Functions are made generic by paying attention to types and making sure types are .hi-blue[stable] --&gt;

&lt;!-- -- --&gt;

&lt;!-- .hi-blue[Type stability:] Given an input into a function, operations on that input should maintain the type so Julia **knows** what its type will be throughout the full function call --&gt;

&lt;!-- -- --&gt;

&lt;!-- This allows it to compile type-specialized versions of the functions, which will yield higher performance --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Generic functions --&gt;

&lt;!-- The question you might have is: Type stability sounds like mandating types (e.g. what C and Fortran do, not what R/Python/etc do), so how do we make it flexible? --&gt;

&lt;!-- -- --&gt;

&lt;!-- We'll see next --&gt;

&lt;!-- --- --&gt;

&lt;!-- # These two functions look the same, but are they? --&gt;

&lt;!-- ```{julia, results = 'hide'} --&gt;
&lt;!-- function t1(n) --&gt;
&lt;!--   s = 0 --&gt;
&lt;!--   t = 1 --&gt;
&lt;!--   for i in 1:n --&gt;
&lt;!--      s += s/i --&gt;
&lt;!--      t = div(t, i) --&gt;
&lt;!--   end --&gt;
&lt;!--   return t --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ```{julia, results = 'hide'} --&gt;
&lt;!-- function t2(n) --&gt;
&lt;!--   s  = 0.0 --&gt;
&lt;!--   t = 1 --&gt;
&lt;!--   for i in 1:n --&gt;
&lt;!--      s += s/i --&gt;
&lt;!--      t = div(t, i) --&gt;
&lt;!--   end --&gt;
&lt;!--   return t --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # No! t1 is not type stable --&gt;

&lt;!-- -- --&gt;

&lt;!-- `t1` starts with `s` as an `Int64` but then we have `s += s/i` which will mean it must hold a `Float64` --&gt;

&lt;!-- -- --&gt;

&lt;!-- It must be converted to `Float` so it is not type stable --&gt;

&lt;!-- --- --&gt;

&lt;!-- # No! t1 is not type stable --&gt;

&lt;!-- We can see this when calling the macro `@code_warntype` where it reports `t1` at some point handles `s` that has type `Union{Float64,Int64}`, either `Float64` or `Int64` --&gt;

&lt;!-- Julia now can't assume `s`'s type and produce pure integer or floating point code `\(\rightarrow\)` performance degradation --&gt;

&lt;!-- &lt;div align="center"&gt; --&gt;
&lt;!--   &lt;img src="figures/t1_codewarn.png" height=150&gt; --&gt;
&lt;!--   &lt;img src="figures/t2_codewarn.png" height=150&gt; --&gt;
&lt;!-- &lt;/div&gt; --&gt;

&lt;!-- --- --&gt;

&lt;!-- # THIS MATTERS --&gt;

&lt;!-- Here's an order of magnitude difference for a similar function --&gt;
&lt;!-- ```{julia, results = 'hide'} --&gt;
&lt;!-- # Type instable --&gt;
&lt;!-- function type_unstable() --&gt;
&lt;!--   x=1 --&gt;
&lt;!--   for i = 1:10 --&gt;
&lt;!--     x = x/2 --&gt;
&lt;!--   end --&gt;
&lt;!--   return x --&gt;
&lt;!-- end --&gt;
&lt;!-- # Type stable --&gt;
&lt;!-- function type_stable() --&gt;
&lt;!--   x=1.0 --&gt;
&lt;!--   for i = 1:10 --&gt;
&lt;!--     x = x/2 --&gt;
&lt;!--   end --&gt;
&lt;!--   return x --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # THIS MATTERS --&gt;

&lt;!-- Here's an order of magnitude difference for a similar function --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- @btime type_unstable() --&gt;
&lt;!-- @btime type_stable() --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Concrete vs abstract types --&gt;

&lt;!-- A **concrete type** is one that can be instantiated (`Float64` `Bool` `Int32`) --&gt;

&lt;!-- -- --&gt;

&lt;!-- An **abstract type** cannot (`Real`, `Number`, `Any`) --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Concrete vs abstract types --&gt;

&lt;!-- Abstract types are for organizing the types --&gt;

&lt;!-- You can check where types are in the hierarchy --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- @show Float64 &lt;: Real --&gt;
&lt;!-- @show Array &lt;: Real --&gt;
&lt;!-- @show Number &lt;: Any --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Concrete vs abstract types --&gt;

&lt;!-- You can see the type hierarchy with the supertypes and subtypes commands --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- using Base: show_supertypes --&gt;
&lt;!-- show_supertypes(Float64) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Creating new types --&gt;

&lt;!-- We can actually create new composite types using `struct` --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- struct FoobarNoType # This will be immutable by default --&gt;
&lt;!--   a --&gt;
&lt;!--   b --&gt;
&lt;!--   c --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Creating new types --&gt;

&lt;!-- This creates a new type called `FoobarNoType`, and we can generate a variable of this type using its **constructor** which will have the same name --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- newfoo = FoobarNoType(1.3, 2, "plzzz"); --&gt;
&lt;!-- typeof(newfoo) --&gt;
&lt;!-- newfoo.a --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- .hi-red[You should always declare types for the fields of a new composite type] --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Creating new types --&gt;

&lt;!-- You can declare types with the double colon --&gt;


&lt;!-- ```{julia} --&gt;
&lt;!-- struct FoobarType # This will be immutable by default --&gt;
&lt;!--   a::Float64 --&gt;
&lt;!--   b::Int --&gt;
&lt;!--   c::String --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Creating new types --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- newfoo_typed = FoobarType(1.3, 2, "plzzz"); --&gt;
&lt;!-- typeof(newfoo_typed) --&gt;
&lt;!-- newfoo.a --&gt;
&lt;!-- ``` --&gt;

&lt;!-- This lets the compiler generate efficient code because it knows the types of the fields when you construct a `FoobarType` --&gt;

&lt;!-- Declaring abstract types isn't good enough, you need to declare concrete types...r do we? --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Parametric types are what help deliver flexibility --&gt;

&lt;!-- We can create types that hold different types of fields --&gt;
&lt;!-- by declaring subsets of abstract types --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- struct FooParam{t1 &lt;: Real, t2 &lt;: Real, t3 &lt;: AbstractArray{&lt;:Real}} --&gt;
&lt;!--   a::t1 --&gt;
&lt;!--   b::t2 --&gt;
&lt;!--   c::t3 --&gt;
&lt;!-- end --&gt;
&lt;!-- newfoo_para = FooParam(1.0, 7, [1., 4., 6.]) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- The curly brackets declare all the different type subsets we will use in `FooParam` --&gt;

&lt;!-- -- --&gt;

&lt;!-- This actually delivers high performance code! --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Delivering flexibility --&gt;

&lt;!-- We want to make sure types are stable but code is flexible --&gt;

&lt;!-- Ex: if want to preallocate an array to store data, --&gt;
&lt;!-- how do we know how to declare it's type? --&gt;

&lt;!-- -- --&gt;

&lt;!-- We don't need to --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Delivering flexibility --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- using LinearAlgebra               # necessary for I --&gt;
&lt;!-- function sametypes(x) --&gt;
&lt;!--   y = similar(x)                  # creates an array that is `similar` to x, use this for preallocating --&gt;
&lt;!--   z = I                           # creates a scalable identity matrix --&gt;
&lt;!--   q = ones(eltype(x), length(x))  # one is a type generic array of ones, fill creates the array of length(x) --&gt;
&lt;!--   y .= z * x + q --&gt;
&lt;!--   return y --&gt;
&lt;!-- end --&gt;

&lt;!-- x = [5.5, 7.0, 3.1]; --&gt;
&lt;!-- y = [7, 8, 9]; --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Delivering flexibility --&gt;

&lt;!-- We did not declare any types but the function is type stable --&gt;


&lt;!-- ```{julia, results = 'hide'} --&gt;
&lt;!-- sametypes(x) --&gt;
&lt;!-- sametypes(y) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- &lt;div align="center"&gt; --&gt;
&lt;!--   &lt;img src="figures/generic_codewarn_float.png" height=125&gt; --&gt;
&lt;!--   &lt;img src="figures/generic_codewarn_int.png" height=125&gt; --&gt;
&lt;!-- &lt;/div&gt; --&gt;

&lt;!-- -- --&gt;

&lt;!-- There's a lot of other functions out there that help with writing flexible, type stable code --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Multiple dispatch --&gt;

&lt;!-- .hi-red[Why type stability really matters: multiple dispatch] --&gt;

&lt;!-- Neat thing about Julia: the same function name can perform different operations depending on the underlying type of the inputs --&gt;

&lt;!-- A function specifies different **methods**, each of which operates on a specific set of types --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Multiple dispatch --&gt;

&lt;!-- When you write a function that's type stable, you are actually writing many different methods, each of which are optimized for certain types --&gt;

&lt;!-- -- --&gt;

&lt;!-- If your function isn't type stable, the optimized method may not be used --&gt;

&lt;!-- This is why Julia can achieve C speeds: it compiles to C (or faster) code --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Multiple dispatch --&gt;

&lt;!-- `/` has 103 different methods depending on the input types, these are 103 specialized sets of codes --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- methods(/) --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;

&lt;!-- # Coding practices etc --&gt;

&lt;!-- See [JuliaPraxis](https://github.com/JuliaPraxis) for best practices for naming, spacing, comments, etc --&gt;



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "4:3"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
