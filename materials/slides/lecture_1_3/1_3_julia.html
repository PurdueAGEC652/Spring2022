<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>AGEC 652 - Lecture 1.3</title>
    <meta charset="utf-8" />
    <meta name="author" content="Diego S. Cardoso" />
    <script src="1_3_julia_files/header-attrs-2.11/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# AGEC 652 - Lecture 1.3
## An introduction to Julia
### Diego S. Cardoso
### Spring 2022

---

exclude: true

```r
if (!require("pacman")) install.packages("pacman")
```

```
## Loading required package: pacman
```

```r
pacman::p_load(
  xaringanthemer, JuliaCall
)

#options(htmltools.dir.version = FALSE)

knitr::opts_hooks$set(fig.callout = function(options) {
  if (options$fig.callout) {
    options$echo &lt;- FALSE
  }

  knitr::opts_chunk$set(echo = TRUE, fig.align="center")
  options
})
```




```julia
using Pkg
Pkg.activate(".")
Pkg.instantiate()
Pkg.add("BenchmarkTools")
```



---

## Software requirements

By now you hopefully have installed
- Julia

- Visual Studio Code with Julia extension
- Jupyter
  - We will take a quick look on how to use VS Code and Jupyter


---

class: inverse, center, middle

# Programming with Julia

.footnote[\*These slides are based on Software Carpentry, notes by Ivan Rudik and Grant Mcdermott, QuantEcon, and Julia documentation.]

---

## Why learn Julia?

**Reason 1: It is easy to learn and use**

Julia is a *high-level* language
- Low-level = you write instructions are closer to what the hardware understands (Assembly, C++, Fortran)
  - .small[E.g.: ]
  - .small[These are usually the fastest because there is little to translate (what a compiler does) and you can optimize your code depending on your hardware]
- High-level means you write in closer to human language (Julia, R, Python)
  - .small[The compiler has to do a lot more work to translate your instructions]

---

## Why learn Julia?

**Reason 2: Julia delivers C++ and Fortran speed**

.small[Sounds like magic, but it's just a clever combination of design choices targeting numerical methods]

&lt;div align="center"&gt;
  &lt;img src="figures/julia_speed_2.png" height=300&gt;
&lt;/div&gt;

.center[.footnote[*In this graph, time to execute in C++ is 1]]

---

## Why learn Julia?

**Reason 3: Julia is free, open-source, and popular**

- You don't need expensive licenses to use (unlike Matlab)

- The people who want to use or verify what you did also don't have to pay

- There is a large and active community of users and developers
  - So it's easy to get help and new packages


---

## .blue[Time for an IDE showcase]

We'll stop the slide show for a while to see two recommended *Integrated Development Environments*, or *IDEs*

- Visual Studio (VS) code

- Jupyter Lab notebooks


---


## Intro to programming

### Programming `\(\equiv\)` writing a set of instructions

- There are hard rules you can't break if you want your code to work

--

- There are elements of style (e.g. Strunk and White) that make your code easier to read, modify, and maintain

--

- There are elements that make your code more efficient
  - Using less time or space (memory)


---

## Intro to programming

If you will be doing computational work, there are:

1. Language-independent coding basics you should know
    - Arrays are stored in memory in particular ways
    
2. Language-independent best practices you should use
    - Indent to convey program structure, naming conventions
    
3. Language-dependent idiosyncracies that matter for function, speed, etc
    - Julia: type stability; R: vectorize

---

## Intro to programming

Learning these early will:

1. Make coding a lot easier
--

2. Reduce total programmer time
--

3. Reduce total computer time
--

4. Make your code understandable by someone else or your future self
--

5. Make your code flexible

---

## A broad view of programming

Your goal is to make a **program**

A program is made of different components and sub-components

--

The most basic component is a **statement**, more commonly called a **line of code**


---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
*deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:

1. Create a deck of cards

---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
*shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:
1. Create a deck of cards
2. Shuffle the deck

---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
*first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:
1. Create a deck of cards
2. Shuffle the deck
3. Draw the top card

---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
*println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:
1. Create a deck of cards
2. Shuffle the deck
3. Draw the top card
4. Print it

---

## A broad view of programming

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

What are the parentheses and why are they different from square brackets?

How does shuffle work?

What’s `println`?

It’s important to know that a **good program has understandable code**

---

## Julia specifics

We will discuss coding in the context of Julia
but a lot of this ports to Python, MATLAB, etc&lt;sup&gt;1&lt;/sup&gt;

We will review

1. Types
2. Iteration
3. Broadcasting/vectorization
4. Scope
5. Generic functions
6. Multiple dispatch


.footnote[&lt;sup&gt;1&lt;/sup&gt;See [https://cheatsheets.quantecon.org](https://cheatsheets.quantecon.org)]

---

## Types: boolean

All languages have some kind of **variable types** like *integers* or *arrays*

--

The first type you will often use is a boolean (`Bool`) variable that takes on a value of `true` or `false`:

```julia
x = true
```

```
## true
```

```julia
typeof(x)
```

```
## Bool
```

---

## Types: boolean

We can save the boolean value of actual statements in variables this way:

```julia
@show y = 1 &gt; 2
```

```
## y = 1 &gt; 2 = false
```

```
## false
```

`@show` is a Julia macro for showing the operation. 
- .small[You can think of a macro as a shortcut name that calls a bunch of other things to run]

---

## Quick detour: logical operators

Logical operators work like you'd think

`==` (equal equal) tests for equality


```julia
1 == 1
```

```
## true
```

--

`!=` (exclaimation point equal) tests for inequality


```julia
2 != 2
```

```
## false
```

---

## Quick detour: logical operators


You can also test for approximate equality with `\(\approx\)` (type `\approx&lt;TAB&gt;`)



```julia
1.00000001 ≈ 1
```

```
## true
```

--

Now back to types

---

## Types: numbers

Two other data types you will use frequently are integers

```julia
typeof(1)
```

```
## Int64
```

--

and floating point numbers

```julia
typeof(1.0)
```

```
## Float64
```

- .small[64 means 64 bits of storage for the number, which is probably the default on your machine]

---

## Types: numbers

You can always instantiate alternative floating point number types


```julia
converted_int = convert(Float32, 1.0);
typeof(converted_int)
```

```
## Float32
```

---

## Types: numbers

### Math works like you would expect:

```julia
a = 2
```

```
## 2
```

```julia
b = 1.0
```

```
## 1.0
```

```julia
a * b
```

```
## 2.0
```

--


```julia
a^2
```

```
## 4
```

---

## Types: numbers


```julia
2a - 4b
```

```
## 0.0
```

--


```julia
@show 4a + 3b^2
```

```
## 4a + 3 * b ^ 2 = 11.0
```

```
## 11.0
```

--

.blue[In Julia, you dont need `*` in between numeric literals (numbers) and variables]

---

## Types: strings

Strings store sequences of characters

You implement them with double quotations:


```julia
x = "Hello World!";
typeof(x)
```

```
## String
```

--

.blue[Note that `;` is used to suppress output for that line of code. Unlike some other languages, in Julia you don't need to add `;` after every command]

---

## Types: strings

It's easy to work with strings. Use `$` to interpolate a variable/expression

```julia
x = 10; y = 20; println("x + y =  $(x+y).")
```

```
## x + y =  30.
```

--

Use `*` to concatenate strings

```julia
a = "Aww"; b = "Yeah!!!"; println(a * " " * b)
```

```
## Aww Yeah!!!
```

--

You probably won't use strings too often unless you're working with text data or printing output. 
--
.blue[Note that `;` can also be used to type multiple commands in the same line. I'm doing it make it fit in this slide, but you should avoid it]


---

## Types: containers

Containers are types that store collections of data

--

The most basic container is the `Array` which is denoted by square brackets

--



```julia
a1 = [1 2; 3 4]; typeof(a1)
```

```
## Matrix{Int64} (alias for Array{Int64, 2})
```

--

Arrays are **mutable**, which means you can change their values

--


```julia
a1[1,1] = 5; a1
```

```
## 2×2 Matrix{Int64}:
##  5  2
##  3  4
```

You reference elements in a container with square brackets

---

## Types: containers

An alternative to the `Array` is the `Tuple`, which is denoted by parentheses

--


```julia
a2 = (1, 2, 3, 4); typeof(a2)
```

```
## NTuple{4, Int64}
```
`a2` is a `Tuple` of 4 `Int64`s. Tuples have no dimension

---

## Types: containers

Tuples are **immutable** which means you **can't** change their values

```julia
try
  a2[1,1] = 5;
catch
  println("Error, can't change value of a tuple.")
end
```

```
## Error, can't change value of a tuple.
```

---

## Types: containers

Tuples don't need parentheses (but it's probably best practice for clarity)

```julia
a3 = 5, 6; typeof(a3)
```

```
## Tuple{Int64, Int64}
```

---

## Types: containers

Tuples can be **unpacked** 

--


```julia
a3_x, a3_y = a3;
a3_x
```

```
## 5
```

```julia
a3_y
```

```
## 6
```

--

This is basically how functions return output when you call them

---

## Types: containers

But an alternative and more efficient container is the  [`NamedTuple`](https://docs.julialang.org/en/v1/manual/types/#Named-Tuple-Types-1) 


```julia
nt = (x = 10, y = 11); typeof(nt)
```

```
## NamedTuple{(:x, :y), Tuple{Int64, Int64}}
```

```julia
nt.x
```

```
## 10
```

```julia
nt.y
```

```
## 11
```

Another way of accessing `x` and `y` inside the NamedTuple is


```julia
nt[:x]; nt[:y];
```


---

## Types: containers

A `Dictionary` is the last main container type. They are like arrays but are indexed by keys (names) instead of numbers

--


```julia
d1 = Dict("class" =&gt; "AEM7130", "grade" =&gt; 97);
typeof(d1)
```

```
## Dict{String, Any}
```

--

`d1` is a dictionary where the key are strings and the values are any kind of type

---

## Types: containers

Reference specific values you want in the dictionary by referencing the key

--


```julia
d1["class"]
```

```
## "AEM7130"
```

```julia
d1["grade"]
```

```
## 97
```

---

## Types: containers

If you just want all the keys or all the values, you can use these base functions


```julia
keys_d1 = keys(d1)
```

```
## KeySet for a Dict{String, Any} with 2 entries. Keys:
##   "class"
##   "grade"
```

```julia
values_d1 = values(d1)
```

```
## ValueIterator for a Dict{String, Any} with 2 entries. Values:
##   "AEM7130"
##   97
```

---

## Iterating

As in other languages we have loops at our disposal:

`for` loops iterate over containers

```julia
for count in 1:10
  random_number = rand()
  if random_number &gt; 0.2
    println("We drew a $random_number.")
  end
end
```

```
## We drew a 0.3125460849121985.
## We drew a 0.5550133158356817.
## We drew a 0.7293142604198248.
## We drew a 0.2537635521825251.
## We drew a 0.3938649845444786.
## We drew a 0.7368122156360689.
## We drew a 0.49158187866664294.
## We drew a 0.4637018697765868.
## We drew a 0.9053711918149782.
```

---

## Iterating

`while` loops iterate until a logical expression is false

```julia
while rand() &gt; 0.5
  random_number = rand()
  if random_number &gt; 0.2
    println("We drew a $random_number.")
  end
end
```

---

## Iterating

An `Iterable` is something you can loop over, like arrays

--


```julia
actions = ["codes well", "skips class"];
for action in actions
    println("Charlie $action")
end
```

```
## Charlie codes well
## Charlie skips class
```

---

## Iterating

The type `Iterator` is a particularly convenient subset of Iterables

--

These include things like the dictionary keys:

```julia
for key in keys(d1)
  println(d1[key])
end
```

```
## AEM7130
## 97
```

---

## Iterating

Iterating on `Iterator`s is more *memory efficient* than iterating on arrays

--

Here's a **very** simple example. The top function iterates on an `Array`, the bottom function iterates on an `Iterator`:

--


```julia
function show_array_speed()
  m = 1
  for i = [1, 2, 3, 4, 5, 6]
    m = m*i
  end
end;

function show_iterator_speed()
  m = 1
  for i = 1:6
    m = m*i
  end
end;
```

---

## Iterating



```julia
using BenchmarkTools
@btime show_array_speed()
```

```
##   25.502 ns (1 allocation: 112 bytes)
```

```julia
@btime show_iterator_speed()
```

```
##   1.800 ns (0 allocations: 0 bytes)
```

The `Iterator` approach is faster and allocates no memory

`@btime` is a macro from `BenchmarkTools` that shows you the elasped time and memory allocation

---

## Neat looping

A nice thing about Julia vs MATLAB: your loops can be much neater because you don't need to index when you just want the container elements

--


```julia
f(x) = x^2;
x_values = 0:20:100;
for x in x_values
  println(f(x))
end
```

```
## 0
## 400
## 1600
## 3600
## 6400
## 10000
```

---

## Neat looping

This loop directly assigns the elements of `x_values` to `x` instead of having to do something clumsy like `x_values[i]`

--

`0:20:100` creates something called a `StepRange` (a type of `Iterator`) which starts at `0`, steps up by `20` and ends at `100`


---

## Neat looping

You can also pull out an index and the element value by enumerating


```julia
f(x) = x^2;
x_values = 0:20:100;
for (index, x) in enumerate(x_values)
  println("f(x) at value $index is $(f(x)).")
end
```

```
## f(x) at value 1 is 0.
## f(x) at value 2 is 400.
## f(x) at value 3 is 1600.
## f(x) at value 4 is 3600.
## f(x) at value 5 is 6400.
## f(x) at value 6 is 10000.
```

`enumerate` basically assigns an index vector

---

## Neat looping

There is also a lot of Python-esque functionality to loop without indexes

For example: `zip` lets you loop over multiple different iterables at once

--


```julia
last_name = ("Lincoln", "Bond", "Walras");
first_name = ("Abraham", "James", "Leon");

for (first_idx, last_idx) in zip(first_name, last_name)
  println("The name's $last_idx, $first_idx $last_idx.")
end
```

```
## The name's Lincoln, Abraham Lincoln.
## The name's Bond, James Bond.
## The name's Walras, Leon Walras.
```

---

## Neat looping

Nested loops can also be made very neatly

--


```julia
for x in 1:3, y in 3:-1:1
  println("$x minus $y is $(x-y)")
end
```

```
## 1 minus 3 is -2
## 1 minus 2 is -1
## 1 minus 1 is 0
## 2 minus 3 is -1
## 2 minus 2 is 0
## 2 minus 1 is 1
## 3 minus 3 is 0
## 3 minus 2 is 1
## 3 minus 1 is 2
```

--

The first loop is the *outer* loop, the second loop is the *inner* loop

---

## Comprehensions: the neatest looping

Comprehensions are an elegant way to use iterables that makes your code cleaner and more compact

--


```julia
squared = [y^2 for y in 1:2:11]
```

```
## 6-element Vector{Int64}:
##    1
##    9
##   25
##   49
##   81
##  121
```

This created a 1-dimension `Array` using one line

---

## Comprehensions: the neatest looping

We can also use nested loops for comprehensions

--


```julia
squared_2 = [(y+z)^2 for y in 1:2:11, z in 1:6]
```

```
## 6×6 Matrix{Int64}:
##    4    9   16   25   36   49
##   16   25   36   49   64   81
##   36   49   64   81  100  121
##   64   81  100  121  144  169
##  100  121  144  169  196  225
##  144  169  196  225  256  289
```

This created a 2-dimensional `Array`

--

Use this (and the compact nested loop) sparingly since it's hard to follow

---

## Dot syntax: broadcasting/vectorization

Vectorizing operations (i.e. applying it to a whole array or vector at once) is easy in Julia: just use *dot syntax* (like in MATLAB)

--


```julia
g(x) = x^2;
squared_2 = g.(1:2:11)
```

```
## 6-element Vector{Int64}:
##    1
##    9
##   25
##   49
##   81
##  121
```

--

This is actually called **broadcasting** in Julia

--

When broadcasting, you might want to consider **pre-allocating** arrays

---

## Dot syntax: broadcasting/vectorization

Vectorization creates *temporary allocations*: temporary arrays in the middle of the process that aren't actually needed for the final product

Julia can do broadcasting in a nicer, faster way by .hi-blue[fusing] operations together and avoiding these temporary allocations

---

## Dot syntax: broadcasting/vectorization

Let's write two functions that do the same thing:


```julia
function show_vec_speed(x)
  out = [3x.^2 + 4x + 7x.^3 for i = 1:1]
end
function show_fuse_speed(x)
  out = @. [3x.^2 + 4x + 7x.^3 for i = 1:1]
end
```

- The top one is vectorized for the operations
- The `@.` in the bottom one vectorizes everything in one swoop: the function call, the operation, and the assignment to a variable

---

## Dot syntax: broadcasting/vectorization

First, precompile the functions


```julia
x = rand(10^6);
@time show_vec_speed(x);
@time show_fuse_speed(x);
```

--

.blue[*Just-in-time compilation* (JIT) is one of the tricks Julia does to make things run faster. It "translates" your code to machine language once and uses that every time you run it again]

---

## Dot syntax: broadcasting/vectorization

Then, let's run and time it


```julia
@time show_vec_speed(x)
```

```
##   0.024529 seconds (13 allocations: 45.777 MiB, 36.27% gc time)
```

```
## 1-element Vector{Vector{Float64}}:
##  [0.559029702302616, 5.015935201888611, 10.395158277033923, 6.503914553691166, 9.23603648016116, 0.16480963951085378, 2.5208976088478625, 4.104891242156411, 8.870125122315631, 1.058540207179492  …  6.586844436324675, 4.955898099265856, 6.656684551726334, 9.274896851654226, 3.629378844429889, 2.187030439096461, 1.076550963345661, 2.3086360545227778, 1.6791689282677904, 11.178615825778879]
```

```julia
@time show_fuse_speed(x)
```

```
##   0.011038 seconds (3 allocations: 7.630 MiB, 80.63% gc time)
```

```
## 1-element Vector{Vector{Float64}}:
##  [0.559029702302616, 5.015935201888611, 10.395158277033923, 6.503914553691166, 9.23603648016116, 0.16480963951085378, 2.5208976088478625, 4.104891242156411, 8.870125122315631, 1.058540207179492  …  6.586844436324675, 4.955898099265856, 6.656684551726334, 9.274896851654226, 3.629378844429889, 2.187030439096461, 1.076550963345661, 2.3086360545227778, 1.6791689282677904, 11.178615825778879]
```

Full vectorization using `@.` is 10x faster with 1/6 of the memory allocation

---

## Dot syntax: vectorization

Not pre-allocated:


```julia
h(y,z) = y^2 + sin(z);   # function to evaluate
y = 1:2:1e6+1;           # input y
z = rand(length(y));     # input z
```

---

## Dot syntax

Here we are vectorizing the *function call*


```julia
# precompile h so first timer isn't picking up on compilation time
h(1,2);
```


```julia
@time out_1 = h.(y,z)    # evaluate h.(y,z) and time
```

```
##   0.072421 seconds (217.48 k allocations: 15.152 MiB, 92.97% compilation time)
```

```
## 500001-element Vector{Float64}:
##    1.050654802000304
##    9.805376277023733
##   25.58117610717384
##   49.65484552706297
##   81.70396509838763
##  121.29654083072255
##  169.31843254474558
##  225.80249601180395
##  289.16327862902415
##  361.63049448540295
##    ⋮
##    9.999700002254835e11
##    9.999740001698293e11
##    9.999780001218011e11
##    9.999820000811732e11
##    9.999860000498339e11
##    9.99990000025809e11
##    9.999940000097559e11
##    9.999980000017087e11
##    1.000002000001438e12
```

---
## Dot syntax: vectorization

Here we are vectorizing the *function call* **and** *assignment*


```julia
out_2 = similar(out_1) # This pre-alocates memory for an object of the same type and size
```


```julia
@time out_2 .= h.(y,z)
```

```
##   0.030975 seconds (48.63 k allocations: 2.340 MiB, 86.13% compilation time)
```

```
## 500001-element Vector{Float64}:
##    1.050654802000304
##    9.805376277023733
##   25.58117610717384
##   49.65484552706297
##   81.70396509838763
##  121.29654083072255
##  169.31843254474558
##  225.80249601180395
##  289.16327862902415
##  361.63049448540295
##    ⋮
##    9.999700002254835e11
##    9.999740001698293e11
##    9.999780001218011e11
##    9.999820000811732e11
##    9.999860000498339e11
##    9.99990000025809e11
##    9.999940000097559e11
##    9.999980000017087e11
##    1.000002000001438e12
```

---
## Dot syntax: vectorization

Here we are vectorizing the *function call* **and** *assignment* **and** *operations*


```julia
out_3 = similar(out_1)
```

```julia
@time @. out_3 = h(y,z)
```

```
##   0.004260 seconds (2 allocations: 128 bytes)
```

```
## 500001-element Vector{Float64}:
##    1.050654802000304
##    9.805376277023733
##   25.58117610717384
##   49.65484552706297
##   81.70396509838763
##  121.29654083072255
##  169.31843254474558
##  225.80249601180395
##  289.16327862902415
##  361.63049448540295
##    ⋮
##    9.999700002254835e11
##    9.999740001698293e11
##    9.999780001218011e11
##    9.999820000811732e11
##    9.999860000498339e11
##    9.99990000025809e11
##    9.999940000097559e11
##    9.999980000017087e11
##    1.000002000001438e12
```

&lt;!-- --- --&gt;


&lt;!-- # Scope --&gt;


&lt;!-- The .hi-blue[scope] of a variable name determines when it is valid to refer to it --&gt;

&lt;!-- -- --&gt;

&lt;!-- Scope can be a frustrating concept --&gt;

&lt;!-- -- --&gt;

&lt;!-- If you want to dive into the details: the type of scoping in Julia is called **lexical scoping** --&gt;

&lt;!-- -- --&gt;

&lt;!-- Different scopes can have the same name, i.e. `saving_rate`, but be assigned to different variables --&gt;

&lt;!-- -- --&gt;

&lt;!-- Let's walk through some simple examples to see how it works --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- First, functions have their own local scope --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- ff(xx) = xx^2; --&gt;
&lt;!-- yy = 5; --&gt;
&lt;!-- ff(yy) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- `xx` isn't bound to any values outside the function `ff` --&gt;

&lt;!-- This is pretty natural for those of you who have done any programming before --&gt;

&lt;!-- --- --&gt;
&lt;!-- # Scope --&gt;

&lt;!-- Locally scoped functions allow us to do things like: --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- xx = 10; --&gt;
&lt;!-- fff(xx) = xx^2; --&gt;
&lt;!-- fff(5) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Although `xx` was declared equal to 10, the function still evaluated at 5 --&gt;

&lt;!-- -- --&gt;

&lt;!-- This is all kind of obvious so far --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- But, this type of scoping also has (initially) counterintuitive results like: --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- zz = 0; --&gt;
&lt;!-- for ii = 1:10 --&gt;
&lt;!--   zz = ii --&gt;
&lt;!-- end --&gt;
&lt;!-- println("zz = $zz") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- What happened? --&gt;

&lt;!-- -- --&gt;

&lt;!-- The `zz` outside the for loop has a different scope, --&gt;
&lt;!-- the .hi-blue[global scope], than the `zz` inside it --&gt;

&lt;!-- -- --&gt;

&lt;!-- The global scope is the outer most scope, outside all functions and loops --&gt;

&lt;!-- -- --&gt;

&lt;!-- The `zz` inside the for loop has a scope .hi-blue[local] to the loop --&gt;

&lt;!-- -- --&gt;

&lt;!-- Since the outside `zz` has global scope the locally scoped variables in the loop can't change it --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- Generally you want to avoid global scope because it can cause conflicts, slowness, etc, but you can use `global` to force it if you want something to have global scope --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- zz = 0; --&gt;
&lt;!-- for ii = 1:10 --&gt;
&lt;!--   global zz --&gt;
&lt;!--   zz = ii --&gt;
&lt;!-- end --&gt;
&lt;!-- println("zz = $zz") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- Local scope kicks in whenever you have a new block keyword (i.e. you indented something) except for `if` --&gt;

&lt;!-- Global variables inside a local scope are inherted for .hi-blue[reading], not writing --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- x, y = 1, 2; --&gt;
&lt;!-- function foo() --&gt;
&lt;!--   x = 2        # assignment introduces a new local --&gt;
&lt;!--   return x + y # y refers to the global --&gt;
&lt;!-- end; --&gt;
&lt;!-- foo() --&gt;
&lt;!-- x --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- Important piece: nested functions can modify their parent scope's .hi-blue[local] variables --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia, results = 'hide'} --&gt;
&lt;!-- x, y = 1, 2; # set globals --&gt;

&lt;!-- function f_outer() --&gt;
&lt;!--   x = 2                # introduces a new local --&gt;
&lt;!--   function f_inner() --&gt;
&lt;!--     x = 10             # modifies the parent's x --&gt;
&lt;!--     return x + y       # y is global --&gt;
&lt;!--   end --&gt;
&lt;!--   return f_inner() + x # 12 + 10 (x is modified in call of f_inner()) --&gt;
&lt;!-- end; --&gt;
&lt;!-- f_outer() --&gt;
&lt;!-- x, y                   # verify that global x and y are unchanged --&gt;
&lt;!-- ``` --&gt;
&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- function f_outer() --&gt;
&lt;!--   x = 2                # introduces a new local --&gt;
&lt;!--   function f_inner() --&gt;
&lt;!--     x = 10             # modifies the parent's x --&gt;
&lt;!--     return x + y       # y is global --&gt;
&lt;!--   end --&gt;
&lt;!--   return f_inner() + x # 12 + 10 (x is modified in call of f_inner()) --&gt;
&lt;!-- end; --&gt;
&lt;!-- f_outer() --&gt;
&lt;!-- x, y                   # verify that global x and y are unchanged --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- If `f_inner` was not nested and was in the global scope we'd get `14` not `22`, this is also a way to handle the issue with loops editing variables not created in their local scope --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- We can fix looping issues with global scope by using a wrapper function that doesn't do anything but change the parent scope so it is not global --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- function wrapper() --&gt;
&lt;!--   zzz = 0; --&gt;
&lt;!--   for iii = 1:10 --&gt;
&lt;!--     zzz = iii --&gt;
&lt;!--   end --&gt;
&lt;!--   println("zzz = $zzz") --&gt;
&lt;!-- end --&gt;
&lt;!-- wrapper() --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Closures --&gt;

&lt;!-- These inner functions we've been looking at are called .hi-blue[closures] --&gt;

&lt;!-- When a function `f` is parsed in Julia, it looks to see if any of the variables have been previously defined in the current scope --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- a = 0.2; --&gt;
&lt;!-- f(x) = a * x^2;    # refers to the `a` in the outer scope --&gt;
&lt;!-- f(1)               # univariate function --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Closures --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- function g(a) --&gt;
&lt;!--     f(x) = a * x^2; # refers to the `a` passed in the function --&gt;
&lt;!--     f(1);           # univariate function --&gt;
&lt;!-- end --&gt;
&lt;!-- g(0.2) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- In both of these examples `f` is a closure designed to .hi-blue[capture] a variable from an outer scope --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Closures --&gt;

&lt;!-- Here's a complicated example that actually returns a closure (a function!) itself: --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Closures --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- x = 0; --&gt;
&lt;!-- function toplevel(y) --&gt;
&lt;!--   println("x = ", x, " is a global variable") --&gt;
&lt;!--   println("y = ", y, " is a parameter") --&gt;
&lt;!--   z = 2 --&gt;
&lt;!--   println("z = ", z, " is a local variable") --&gt;

&lt;!--   function closure(v) --&gt;
&lt;!--     println("v = ", v, " is a parameter") --&gt;
&lt;!--     w = 3 --&gt;
&lt;!--     println("w = ", w, " is a local variable") --&gt;
&lt;!--     println("x = ", x, " is a global variable") --&gt;
&lt;!--     println("y = ", y, " is a closed variable (a parameter of the outer function)") --&gt;
&lt;!--     println("z = ", z, " is a closed variable (a local of the outer function)") --&gt;
&lt;!--   end; --&gt;
&lt;!--   return closure --&gt;
&lt;!-- end; --&gt;
&lt;!-- ``` --&gt;
&lt;!-- What will be returned when we call these functions? --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Closures --&gt;

&lt;!-- Here's a complicated example: --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- c_func = toplevel(10) --&gt;
&lt;!-- c_func(20) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- The returned closure still has access to the outer function's local scope! --&gt;



&lt;!-- --- --&gt;

&lt;!-- # Generic functions --&gt;

&lt;!-- If you use Julia to write code for research you should aim to write .hi-blue[generic functions] --&gt;

&lt;!-- -- --&gt;

&lt;!-- These are functions that are flexible (e.g. can deal with someone using an `Int` instead of a `Float`) --&gt;
&lt;!-- and have high performance (e.g. comparable speed to C) --&gt;

&lt;!-- -- --&gt;

&lt;!-- Functions are made generic by paying attention to types and making sure types are .hi-blue[stable] --&gt;

&lt;!-- -- --&gt;

&lt;!-- .hi-blue[Type stability:] Given an input into a function, operations on that input should maintain the type so Julia **knows** what its type will be throughout the full function call --&gt;

&lt;!-- -- --&gt;

&lt;!-- This allows it to compile type-specialized versions of the functions, which will yield higher performance --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Generic functions --&gt;

&lt;!-- The question you might have is: Type stability sounds like mandating types (e.g. what C and Fortran do, not what R/Python/etc do), so how do we make it flexible? --&gt;

&lt;!-- -- --&gt;

&lt;!-- We'll see next --&gt;

&lt;!-- --- --&gt;

&lt;!-- # These two functions look the same, but are they? --&gt;

&lt;!-- ```{julia, results = 'hide'} --&gt;
&lt;!-- function t1(n) --&gt;
&lt;!--   s = 0 --&gt;
&lt;!--   t = 1 --&gt;
&lt;!--   for i in 1:n --&gt;
&lt;!--      s += s/i --&gt;
&lt;!--      t = div(t, i) --&gt;
&lt;!--   end --&gt;
&lt;!--   return t --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ```{julia, results = 'hide'} --&gt;
&lt;!-- function t2(n) --&gt;
&lt;!--   s  = 0.0 --&gt;
&lt;!--   t = 1 --&gt;
&lt;!--   for i in 1:n --&gt;
&lt;!--      s += s/i --&gt;
&lt;!--      t = div(t, i) --&gt;
&lt;!--   end --&gt;
&lt;!--   return t --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # No! t1 is not type stable --&gt;

&lt;!-- -- --&gt;

&lt;!-- `t1` starts with `s` as an `Int64` but then we have `s += s/i` which will mean it must hold a `Float64` --&gt;

&lt;!-- -- --&gt;

&lt;!-- It must be converted to `Float` so it is not type stable --&gt;

&lt;!-- --- --&gt;

&lt;!-- # No! t1 is not type stable --&gt;

&lt;!-- We can see this when calling the macro `@code_warntype` where it reports `t1` at some point handles `s` that has type `Union{Float64,Int64}`, either `Float64` or `Int64` --&gt;

&lt;!-- Julia now can't assume `s`'s type and produce pure integer or floating point code `\(\rightarrow\)` performance degradation --&gt;

&lt;!-- &lt;div align="center"&gt; --&gt;
&lt;!--   &lt;img src="figures/t1_codewarn.png" height=150&gt; --&gt;
&lt;!--   &lt;img src="figures/t2_codewarn.png" height=150&gt; --&gt;
&lt;!-- &lt;/div&gt; --&gt;

&lt;!-- --- --&gt;

&lt;!-- # THIS MATTERS --&gt;

&lt;!-- Here's an order of magnitude difference for a similar function --&gt;
&lt;!-- ```{julia, results = 'hide'} --&gt;
&lt;!-- # Type instable --&gt;
&lt;!-- function type_unstable() --&gt;
&lt;!--   x=1 --&gt;
&lt;!--   for i = 1:10 --&gt;
&lt;!--     x = x/2 --&gt;
&lt;!--   end --&gt;
&lt;!--   return x --&gt;
&lt;!-- end --&gt;
&lt;!-- # Type stable --&gt;
&lt;!-- function type_stable() --&gt;
&lt;!--   x=1.0 --&gt;
&lt;!--   for i = 1:10 --&gt;
&lt;!--     x = x/2 --&gt;
&lt;!--   end --&gt;
&lt;!--   return x --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # THIS MATTERS --&gt;

&lt;!-- Here's an order of magnitude difference for a similar function --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- @btime type_unstable() --&gt;
&lt;!-- @btime type_stable() --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Concrete vs abstract types --&gt;

&lt;!-- A **concrete type** is one that can be instantiated (`Float64` `Bool` `Int32`) --&gt;

&lt;!-- -- --&gt;

&lt;!-- An **abstract type** cannot (`Real`, `Number`, `Any`) --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Concrete vs abstract types --&gt;

&lt;!-- Abstract types are for organizing the types --&gt;

&lt;!-- You can check where types are in the hierarchy --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- @show Float64 &lt;: Real --&gt;
&lt;!-- @show Array &lt;: Real --&gt;
&lt;!-- @show Number &lt;: Any --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Concrete vs abstract types --&gt;

&lt;!-- You can see the type hierarchy with the supertypes and subtypes commands --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- using Base: show_supertypes --&gt;
&lt;!-- show_supertypes(Float64) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Creating new types --&gt;

&lt;!-- We can actually create new composite types using `struct` --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- struct FoobarNoType # This will be immutable by default --&gt;
&lt;!--   a --&gt;
&lt;!--   b --&gt;
&lt;!--   c --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Creating new types --&gt;

&lt;!-- This creates a new type called `FoobarNoType`, and we can generate a variable of this type using its **constructor** which will have the same name --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- newfoo = FoobarNoType(1.3, 2, "plzzz"); --&gt;
&lt;!-- typeof(newfoo) --&gt;
&lt;!-- newfoo.a --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- .hi-red[You should always declare types for the fields of a new composite type] --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Creating new types --&gt;

&lt;!-- You can declare types with the double colon --&gt;


&lt;!-- ```{julia} --&gt;
&lt;!-- struct FoobarType # This will be immutable by default --&gt;
&lt;!--   a::Float64 --&gt;
&lt;!--   b::Int --&gt;
&lt;!--   c::String --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Creating new types --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- newfoo_typed = FoobarType(1.3, 2, "plzzz"); --&gt;
&lt;!-- typeof(newfoo_typed) --&gt;
&lt;!-- newfoo.a --&gt;
&lt;!-- ``` --&gt;

&lt;!-- This lets the compiler generate efficient code because it knows the types of the fields when you construct a `FoobarType` --&gt;

&lt;!-- Declaring abstract types isn't good enough, you need to declare concrete types...r do we? --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Parametric types are what help deliver flexibility --&gt;

&lt;!-- We can create types that hold different types of fields --&gt;
&lt;!-- by declaring subsets of abstract types --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- struct FooParam{t1 &lt;: Real, t2 &lt;: Real, t3 &lt;: AbstractArray{&lt;:Real}} --&gt;
&lt;!--   a::t1 --&gt;
&lt;!--   b::t2 --&gt;
&lt;!--   c::t3 --&gt;
&lt;!-- end --&gt;
&lt;!-- newfoo_para = FooParam(1.0, 7, [1., 4., 6.]) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- The curly brackets declare all the different type subsets we will use in `FooParam` --&gt;

&lt;!-- -- --&gt;

&lt;!-- This actually delivers high performance code! --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Delivering flexibility --&gt;

&lt;!-- We want to make sure types are stable but code is flexible --&gt;

&lt;!-- Ex: if want to preallocate an array to store data, --&gt;
&lt;!-- how do we know how to declare it's type? --&gt;

&lt;!-- -- --&gt;

&lt;!-- We don't need to --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Delivering flexibility --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- using LinearAlgebra               # necessary for I --&gt;
&lt;!-- function sametypes(x) --&gt;
&lt;!--   y = similar(x)                  # creates an array that is `similar` to x, use this for preallocating --&gt;
&lt;!--   z = I                           # creates a scalable identity matrix --&gt;
&lt;!--   q = ones(eltype(x), length(x))  # one is a type generic array of ones, fill creates the array of length(x) --&gt;
&lt;!--   y .= z * x + q --&gt;
&lt;!--   return y --&gt;
&lt;!-- end --&gt;

&lt;!-- x = [5.5, 7.0, 3.1]; --&gt;
&lt;!-- y = [7, 8, 9]; --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Delivering flexibility --&gt;

&lt;!-- We did not declare any types but the function is type stable --&gt;


&lt;!-- ```{julia, results = 'hide'} --&gt;
&lt;!-- sametypes(x) --&gt;
&lt;!-- sametypes(y) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- &lt;div align="center"&gt; --&gt;
&lt;!--   &lt;img src="figures/generic_codewarn_float.png" height=125&gt; --&gt;
&lt;!--   &lt;img src="figures/generic_codewarn_int.png" height=125&gt; --&gt;
&lt;!-- &lt;/div&gt; --&gt;

&lt;!-- -- --&gt;

&lt;!-- There's a lot of other functions out there that help with writing flexible, type stable code --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Multiple dispatch --&gt;

&lt;!-- .hi-red[Why type stability really matters: multiple dispatch] --&gt;

&lt;!-- Neat thing about Julia: the same function name can perform different operations depending on the underlying type of the inputs --&gt;

&lt;!-- A function specifies different **methods**, each of which operates on a specific set of types --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Multiple dispatch --&gt;

&lt;!-- When you write a function that's type stable, you are actually writing many different methods, each of which are optimized for certain types --&gt;

&lt;!-- -- --&gt;

&lt;!-- If your function isn't type stable, the optimized method may not be used --&gt;

&lt;!-- This is why Julia can achieve C speeds: it compiles to C (or faster) code --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Multiple dispatch --&gt;

&lt;!-- `/` has 103 different methods depending on the input types, these are 103 specialized sets of codes --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- methods(/) --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;

&lt;!-- # Coding practices etc --&gt;

&lt;!-- See [JuliaPraxis](https://github.com/JuliaPraxis) for best practices for naming, spacing, comments, etc --&gt;



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
