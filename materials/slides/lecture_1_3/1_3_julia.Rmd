---
title: "AGEC 652 - Lecture 1.3"
subtitle: "An introduction to Julia"
date: "Spring 2022"
author: "Diego S. Cardoso"
#institute: "Purdue University, Department of Agricultural Economics"
output:
  xaringan::moon_reader:
    css: xaringan-themer.css
    # self_contained: true
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: '16:9'
---
exclude: true
```{r setup}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(
  xaringanthemer, JuliaCall
)

#options(htmltools.dir.version = FALSE)

knitr::opts_hooks$set(fig.callout = function(options) {
  if (options$fig.callout) {
    options$echo <- FALSE
  }

  knitr::opts_chunk$set(echo = TRUE, fig.align="center")
  options
})

```

```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
style_mono_accent(
  base_color = "#8E6F3E", 
  header_font_google = google_font("Josefin Sans"),
  text_font_size = "28px",
  colors = c(
    red = "#f34213",
    gold = "#CFB991",
    gray = "CFB991",
    blue = "#295fbe",
    black = "#000000"
  )
)

extra_css <- list(
  ".small" = list("font-size" = "90%"),
  ".big" = list("font-size" = "125%"),
  ".footnote" = list("font-size" = "60%"), 
  ".full-width" = list(
    display = "flex",
    width   = "100%",
    flex    = "1 1 auto"
  )
)

style_extra_css(css = extra_css)

```

```{julia}
using Pkg
Pkg.activate(".")
Pkg.instantiate()
Pkg.add("BenchmarkTools")
```



---

## Software requirements

By now you hopefully have installed
- Julia

- Visual Studio Code with Julia extension
- Jupyter
  - We will take a quick look on how to use VS Code and Jupyter


---

class: inverse, center, middle

# Programming with Julia

.footnote[\*These slides are based on Software Carpentry, notes by Ivan Rudik and Grant Mcdermott, QuantEcon, and Julia documentation.]

---

## Why learn Julia?

**Reason 1: It is easy to learn and use**

Julia is a *high-level* language
- Low-level = you write instructions are closer to what the hardware understands (Assembly, C++, Fortran)
  - .small[E.g.: ]
  - .small[These are usually the fastest because there is little to translate (what a compiler does) and you can optimize your code depending on your hardware]
- High-level means you write in closer to human language (Julia, R, Python)
  - .small[The compiler has to do a lot more work to translate your instructions]

---

## Why learn Julia?

**Reason 2: Julia delivers C++ and Fortran speed**

.small[Sounds like magic, but it's just a clever combination of design choices targeting numerical methods]

<div align="center">
  <img src="figures/julia_speed_2.png" height=300>
</div>

.center[.footnote[*In this graph, time to execute in C++ is 1]]

---

## Why learn Julia?

**Reason 3: Julia is free, open-source, and popular**

- You don't need expensive licenses to use (unlike Matlab)

- The people who want to use or verify what you did also don't have to pay

- There is a large and active community of users and developers
  - So it's easy to get help and new packages


---

## .blue[Time for an IDE showcase]

We'll stop the slide show for a while to see two recommended *Integrated Development Environments*, or *IDEs*

- Visual Studio (VS) code

- Jupyter Lab notebooks


---


## Intro to programming

### Programming $\equiv$ writing a set of instructions

- There are hard rules you can't break if you want your code to work

--

- There are elements of style (e.g. Strunk and White) that make your code easier to read, modify, and maintain

--

- There are elements that make your code more efficient
  - Using less time or space (memory)


---

## Intro to programming

If you will be doing computational work, there are:

1. Language-independent coding basics you should know
    - Arrays are stored in memory in particular ways
    
2. Language-independent best practices you should use
    - Indent to convey program structure, naming conventions
    
3. Language-dependent idiosyncracies that matter for function, speed, etc
    - Julia: type stability; R: vectorize

---

## Intro to programming

Learning these early will:

1. Make coding a lot easier
--

2. Reduce total programmer time
--

3. Reduce total computer time
--

4. Make your code understandable by someone else or your future self
--

5. Make your code flexible

---

## A broad view of programming

Your goal is to make a **program**

A program is made of different components and sub-components

--

The most basic component is a **statement**, more commonly called a **line of code**


---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
*deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:

1. Create a deck of cards

---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
*shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:
1. Create a deck of cards
2. Shuffle the deck

---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
*first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:
1. Create a deck of cards
2. Shuffle the deck
3. Draw the top card

---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
*println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:
1. Create a deck of cards
2. Shuffle the deck
3. Draw the top card
4. Print it

---

## A broad view of programming

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

What are the parentheses and why are they different from square brackets?

How does shuffle work?

What’s `println`?

It’s important to know that a **good program has understandable code**

---

## Julia specifics

We will discuss coding in the context of Julia
but a lot of this ports to Python, MATLAB, etc<sup>1</sup>

We will review

1. Types
2. Iteration
3. Broadcasting/vectorization
4. Scope
5. Generic functions
6. Multiple dispatch


.footnote[<sup>1</sup>See [https://cheatsheets.quantecon.org](https://cheatsheets.quantecon.org)]

---

## Types: boolean

All languages have some kind of **variable types** like *integers* or *arrays*

--

The first type you will often use is a boolean (`Bool`) variable that takes on a value of `true` or `false`:
```{julia}
x = true
typeof(x)
```

---

## Types: boolean

We can save the boolean value of actual statements in variables this way:
```{julia}
@show y = 1 > 2
```

`@show` is a Julia macro for showing the operation. 
- .small[You can think of a macro as a shortcut name that calls a bunch of other things to run]

---

## Quick detour: logical operators

Logical operators work like you'd think

`==` (equal equal) tests for equality

```{julia}
1 == 1
```

--

`!=` (exclaimation point equal) tests for inequality

```{julia}
2 != 2
```

---

## Quick detour: logical operators


You can also test for approximate equality with $\approx$ (type `\approx<TAB>`)


```{julia}
1.00000001 ≈ 1
```

--

Now back to types

---

## Types: numbers

Two other data types you will use frequently are integers
```{julia}
typeof(1)
```

--

and floating point numbers
```{julia}
typeof(1.0)
```

- .small[64 means 64 bits of storage for the number, which is probably the default on your machine]

---

## Types: numbers

You can always instantiate alternative floating point number types

```{julia}
converted_int = convert(Float32, 1.0);
typeof(converted_int)
```

---

## Types: numbers

### Math works like you would expect:
```{julia}
a = 2
b = 1.0
a * b
```

--

```{julia}
a^2
```

---

## Types: numbers

```{julia}
2a - 4b
```

--

```{julia}
@show 4a + 3b^2
```

--

.blue[In Julia, you dont need `*` in between numeric literals (numbers) and variables]

---

## Types: strings

Strings store sequences of characters

You implement them with double quotations:

```{julia}
x = "Hello World!";
typeof(x)
```

--

.blue[Note that `;` is used to suppress output for that line of code. Unlike some other languages, in Julia you don't need to add `;` after every command]

---

## Types: strings

It's easy to work with strings. Use `$` to interpolate a variable/expression
```{julia}
x = 10; y = 20; println("x + y =  $(x+y).")
```

--

Use `*` to concatenate strings
```{julia}
a = "Aww"; b = "Yeah!!!"; println(a * " " * b)
```

--

You probably won't use strings too often unless you're working with text data or printing output. 
--
.blue[Note that `;` can also be used to type multiple commands in the same line. I'm doing it make it fit in this slide, but you should avoid it]


---

## Types: containers

Containers are types that store collections of data

--

The most basic container is the `Array` which is denoted by square brackets

--


```{julia}
a1 = [1 2; 3 4]; typeof(a1)
```

--

Arrays are **mutable**, which means you can change their values

--

```{julia}
a1[1,1] = 5; a1
```

You reference elements in a container with square brackets

---

## Types: containers

An alternative to the `Array` is the `Tuple`, which is denoted by parentheses

--

```{julia}
a2 = (1, 2, 3, 4); typeof(a2)
```
`a2` is a `Tuple` of 4 `Int64`s. Tuples have no dimension

---

## Types: containers

Tuples are **immutable** which means you **can't** change their values
```{julia}
try
  a2[1,1] = 5;
catch
  println("Error, can't change value of a tuple.")
end
```

---

## Types: containers

Tuples don't need parentheses (but it's probably best practice for clarity)
```{julia}
a3 = 5, 6; typeof(a3)
```

---

## Types: containers

Tuples can be **unpacked** 

--

```{julia}
a3_x, a3_y = a3;
a3_x
a3_y
```

--

This is basically how functions return output when you call them

---

## Types: containers

But an alternative and more efficient container is the  [`NamedTuple`](https://docs.julialang.org/en/v1/manual/types/#Named-Tuple-Types-1) 

```{julia}
nt = (x = 10, y = 11); typeof(nt)
nt.x
nt.y
```

Another way of accessing `x` and `y` inside the NamedTuple is

```{julia}
nt[:x]; nt[:y];
```


---

## Types: containers

A `Dictionary` is the last main container type. They are like arrays but are indexed by keys (names) instead of numbers

--

```{julia}
d1 = Dict("class" => "AEM7130", "grade" => 97);
typeof(d1)
```

--

`d1` is a dictionary where the key are strings and the values are any kind of type

---

## Types: containers

Reference specific values you want in the dictionary by referencing the key

--

```{julia}
d1["class"]
d1["grade"]
```

---

## Types: containers

If you just want all the keys or all the values, you can use these base functions

```{julia}
keys_d1 = keys(d1)
values_d1 = values(d1)
```

---

## Iterating

As in other languages we have loops at our disposal:

`for` loops iterate over containers
```{julia}
for count in 1:10
  random_number = rand()
  if random_number > 0.2
    println("We drew a $random_number.")
  end
end
```

---

## Iterating

`while` loops iterate until a logical expression is false
```{julia}
while rand() > 0.5
  random_number = rand()
  if random_number > 0.2
    println("We drew a $random_number.")
  end
end
```

---

## Iterating

An `Iterable` is something you can loop over, like arrays

--

```{julia}
actions = ["codes well", "skips class"];
for action in actions
    println("Charlie $action")
end
```

---

## Iterating

The type `Iterator` is a particularly convenient subset of Iterables

--

These include things like the dictionary keys:
```{julia}
for key in keys(d1)
  println(d1[key])
end
```

---

## Iterating

Iterating on `Iterator`s is more *memory efficient* than iterating on arrays

--

Here's a **very** simple example. The top function iterates on an `Array`, the bottom function iterates on an `Iterator`:

--

```{julia}
function show_array_speed()
  m = 1
  for i = [1, 2, 3, 4, 5, 6]
    m = m*i
  end
end;

function show_iterator_speed()
  m = 1
  for i = 1:6
    m = m*i
  end
end;
```

---

## Iterating


```{julia}
using BenchmarkTools
@btime show_array_speed()
@btime show_iterator_speed()
```

The `Iterator` approach is faster and allocates no memory

`@btime` is a macro from `BenchmarkTools` that shows you the elasped time and memory allocation

---

## Neat looping

A nice thing about Julia vs MATLAB: your loops can be much neater because you don't need to index when you just want the container elements

--

```{julia}
f(x) = x^2;
x_values = 0:20:100;
for x in x_values
  println(f(x))
end
```

---

## Neat looping

This loop directly assigns the elements of `x_values` to `x` instead of having to do something clumsy like `x_values[i]`

--

`0:20:100` creates something called a `StepRange` (a type of `Iterator`) which starts at `0`, steps up by `20` and ends at `100`


---

## Neat looping

You can also pull out an index and the element value by enumerating

```{julia}
f(x) = x^2;
x_values = 0:20:100;
for (index, x) in enumerate(x_values)
  println("f(x) at value $index is $(f(x)).")
end
```

`enumerate` basically assigns an index vector

---

## Neat looping

There is also a lot of Python-esque functionality to loop without indexes

For example: `zip` lets you loop over multiple different iterables at once

--

```{julia}
last_name = ("Lincoln", "Bond", "Walras");
first_name = ("Abraham", "James", "Leon");

for (first_idx, last_idx) in zip(first_name, last_name)
  println("The name's $last_idx, $first_idx $last_idx.")
end
```

---

## Neat looping

Nested loops can also be made very neatly

--

```{julia}
for x in 1:3, y in 3:-1:1
  println("$x minus $y is $(x-y)")
end
```

--

The first loop is the *outer* loop, the second loop is the *inner* loop

---

## Comprehensions: the neatest looping

Comprehensions are an elegant way to use iterables that makes your code cleaner and more compact

--

```{julia}
squared = [y^2 for y in 1:2:11]
```

This created a 1-dimension `Array` using one line

---

## Comprehensions: the neatest looping

We can also use nested loops for comprehensions

--

```{julia}
squared_2 = [(y+z)^2 for y in 1:2:11, z in 1:6]
```

This created a 2-dimensional `Array`

--

Use this (and the compact nested loop) sparingly since it's hard to follow

---

## Dot syntax: broadcasting/vectorization

Vectorizing operations (i.e. applying it to a whole array or vector at once) is easy in Julia: just use *dot syntax* (like in MATLAB)

--

```{julia}
g(x) = x^2;
squared_2 = g.(1:2:11)
```

--

This is actually called **broadcasting** in Julia

--

When broadcasting, you might want to consider **pre-allocating** arrays

---

## Dot syntax: broadcasting/vectorization

Vectorization creates *temporary allocations*: temporary arrays in the middle of the process that aren't actually needed for the final product

Julia can do broadcasting in a nicer, faster way by .hi-blue[fusing] operations together and avoiding these temporary allocations

---

## Dot syntax: broadcasting/vectorization

Let's write two functions that do the same thing:

```{julia, results = 'hide'}
function show_vec_speed(x)
  out = [3x.^2 + 4x + 7x.^3 for i = 1:1]
end
function show_fuse_speed(x)
  out = @. [3x.^2 + 4x + 7x.^3 for i = 1:1]
end
```

- The top one is vectorized for the operations
- The `@.` in the bottom one vectorizes everything in one swoop: the function call, the operation, and the assignment to a variable

---

## Dot syntax: broadcasting/vectorization

First, precompile the functions

```{julia}
x = rand(10^6);
@time show_vec_speed(x);
@time show_fuse_speed(x);
```

--

.blue[*Just-in-time compilation* (JIT) is one of the tricks Julia does to make things run faster. It "translates" your code to machine language once and uses that every time you run it again]

---

## Dot syntax: broadcasting/vectorization

Then, let's run and time it

```{julia}
@time show_vec_speed(x)
@time show_fuse_speed(x)
```

Full vectorization using `@.` is 10x faster with 1/6 of the memory allocation

---

## Dot syntax: vectorization

Not pre-allocated:

```{julia, results = 'hide'}
h(y,z) = y^2 + sin(z);   # function to evaluate
y = 1:2:1e6+1;           # input y
z = rand(length(y));     # input z
```

---

## Dot syntax

Here we are vectorizing the *function call*

```{julia, results = 'hide'}
# precompile h so first timer isn't picking up on compilation time
h(1,2);
```

```{julia}
@time out_1 = h.(y,z)    # evaluate h.(y,z) and time
```

---
## Dot syntax: vectorization

Here we are vectorizing the *function call* **and** *assignment*

```{julia, results = 'hide'}
out_2 = similar(out_1) # This pre-alocates memory for an object of the same type and size
```

```{julia}
@time out_2 .= h.(y,z)
```

---
## Dot syntax: vectorization

Here we are vectorizing the *function call* **and** *assignment* **and** *operations*

```{julia, results = 'hide'}
out_3 = similar(out_1)
```
```{julia}
@time @. out_3 = h(y,z)
```

<!-- Include an explanation of what's happening with this example: https://docs.julialang.org/en/v1/manual/performance-tips/#More-dots:-Fuse-vectorized-operations -->

<!-- --- -->


<!-- # Scope -->


<!-- The .hi-blue[scope] of a variable name determines when it is valid to refer to it -->

<!-- -- -->

<!-- Scope can be a frustrating concept -->

<!-- -- -->

<!-- If you want to dive into the details: the type of scoping in Julia is called **lexical scoping** -->

<!-- -- -->

<!-- Different scopes can have the same name, i.e. `saving_rate`, but be assigned to different variables -->

<!-- -- -->

<!-- Let's walk through some simple examples to see how it works -->

<!-- --- -->

<!-- # Scope -->

<!-- First, functions have their own local scope -->

<!-- -- -->

<!-- ```{julia} -->
<!-- ff(xx) = xx^2; -->
<!-- yy = 5; -->
<!-- ff(yy) -->
<!-- ``` -->

<!-- `xx` isn't bound to any values outside the function `ff` -->

<!-- This is pretty natural for those of you who have done any programming before -->

<!-- --- -->
<!-- # Scope -->

<!-- Locally scoped functions allow us to do things like: -->

<!-- ```{julia} -->
<!-- xx = 10; -->
<!-- fff(xx) = xx^2; -->
<!-- fff(5) -->
<!-- ``` -->

<!-- Although `xx` was declared equal to 10, the function still evaluated at 5 -->

<!-- -- -->

<!-- This is all kind of obvious so far -->

<!-- --- -->

<!-- # Scope -->

<!-- But, this type of scoping also has (initially) counterintuitive results like: -->

<!-- ```{julia} -->
<!-- zz = 0; -->
<!-- for ii = 1:10 -->
<!--   zz = ii -->
<!-- end -->
<!-- println("zz = $zz") -->
<!-- ``` -->

<!-- --- -->

<!-- # Scope -->

<!-- What happened? -->

<!-- -- -->

<!-- The `zz` outside the for loop has a different scope, -->
<!-- the .hi-blue[global scope], than the `zz` inside it -->

<!-- -- -->

<!-- The global scope is the outer most scope, outside all functions and loops -->

<!-- -- -->

<!-- The `zz` inside the for loop has a scope .hi-blue[local] to the loop -->

<!-- -- -->

<!-- Since the outside `zz` has global scope the locally scoped variables in the loop can't change it -->

<!-- --- -->

<!-- # Scope -->

<!-- Generally you want to avoid global scope because it can cause conflicts, slowness, etc, but you can use `global` to force it if you want something to have global scope -->

<!-- ```{julia} -->
<!-- zz = 0; -->
<!-- for ii = 1:10 -->
<!--   global zz -->
<!--   zz = ii -->
<!-- end -->
<!-- println("zz = $zz") -->
<!-- ``` -->

<!-- --- -->

<!-- # Scope -->

<!-- Local scope kicks in whenever you have a new block keyword (i.e. you indented something) except for `if` -->

<!-- Global variables inside a local scope are inherted for .hi-blue[reading], not writing -->

<!-- ```{julia} -->
<!-- x, y = 1, 2; -->
<!-- function foo() -->
<!--   x = 2        # assignment introduces a new local -->
<!--   return x + y # y refers to the global -->
<!-- end; -->
<!-- foo() -->
<!-- x -->
<!-- ``` -->


<!-- --- -->

<!-- # Scope -->

<!-- Important piece: nested functions can modify their parent scope's .hi-blue[local] variables -->

<!-- -- -->

<!-- ```{julia, results = 'hide'} -->
<!-- x, y = 1, 2; # set globals -->

<!-- function f_outer() -->
<!--   x = 2                # introduces a new local -->
<!--   function f_inner() -->
<!--     x = 10             # modifies the parent's x -->
<!--     return x + y       # y is global -->
<!--   end -->
<!--   return f_inner() + x # 12 + 10 (x is modified in call of f_inner()) -->
<!-- end; -->
<!-- f_outer() -->
<!-- x, y                   # verify that global x and y are unchanged -->
<!-- ``` -->
<!-- --- -->

<!-- # Scope -->

<!-- ```{julia} -->
<!-- function f_outer() -->
<!--   x = 2                # introduces a new local -->
<!--   function f_inner() -->
<!--     x = 10             # modifies the parent's x -->
<!--     return x + y       # y is global -->
<!--   end -->
<!--   return f_inner() + x # 12 + 10 (x is modified in call of f_inner()) -->
<!-- end; -->
<!-- f_outer() -->
<!-- x, y                   # verify that global x and y are unchanged -->
<!-- ``` -->

<!-- -- -->

<!-- If `f_inner` was not nested and was in the global scope we'd get `14` not `22`, this is also a way to handle the issue with loops editing variables not created in their local scope -->

<!-- --- -->

<!-- # Scope -->

<!-- We can fix looping issues with global scope by using a wrapper function that doesn't do anything but change the parent scope so it is not global -->

<!-- ```{julia} -->
<!-- function wrapper() -->
<!--   zzz = 0; -->
<!--   for iii = 1:10 -->
<!--     zzz = iii -->
<!--   end -->
<!--   println("zzz = $zzz") -->
<!-- end -->
<!-- wrapper() -->
<!-- ``` -->

<!-- --- -->

<!-- # Closures -->

<!-- These inner functions we've been looking at are called .hi-blue[closures] -->

<!-- When a function `f` is parsed in Julia, it looks to see if any of the variables have been previously defined in the current scope -->

<!-- ```{julia} -->
<!-- a = 0.2; -->
<!-- f(x) = a * x^2;    # refers to the `a` in the outer scope -->
<!-- f(1)               # univariate function -->
<!-- ``` -->

<!-- --- -->

<!-- # Closures -->

<!-- ```{julia} -->
<!-- function g(a) -->
<!--     f(x) = a * x^2; # refers to the `a` passed in the function -->
<!--     f(1);           # univariate function -->
<!-- end -->
<!-- g(0.2) -->
<!-- ``` -->

<!-- -- -->

<!-- In both of these examples `f` is a closure designed to .hi-blue[capture] a variable from an outer scope -->

<!-- --- -->

<!-- # Closures -->

<!-- Here's a complicated example that actually returns a closure (a function!) itself: -->

<!-- --- -->

<!-- # Closures -->

<!-- ```{julia} -->
<!-- x = 0; -->
<!-- function toplevel(y) -->
<!--   println("x = ", x, " is a global variable") -->
<!--   println("y = ", y, " is a parameter") -->
<!--   z = 2 -->
<!--   println("z = ", z, " is a local variable") -->

<!--   function closure(v) -->
<!--     println("v = ", v, " is a parameter") -->
<!--     w = 3 -->
<!--     println("w = ", w, " is a local variable") -->
<!--     println("x = ", x, " is a global variable") -->
<!--     println("y = ", y, " is a closed variable (a parameter of the outer function)") -->
<!--     println("z = ", z, " is a closed variable (a local of the outer function)") -->
<!--   end; -->
<!--   return closure -->
<!-- end; -->
<!-- ``` -->
<!-- What will be returned when we call these functions? -->

<!-- --- -->

<!-- # Closures -->

<!-- Here's a complicated example: -->

<!-- ```{julia} -->
<!-- c_func = toplevel(10) -->
<!-- c_func(20) -->
<!-- ``` -->

<!-- The returned closure still has access to the outer function's local scope! -->



<!-- --- -->

<!-- # Generic functions -->

<!-- If you use Julia to write code for research you should aim to write .hi-blue[generic functions] -->

<!-- -- -->

<!-- These are functions that are flexible (e.g. can deal with someone using an `Int` instead of a `Float`) -->
<!-- and have high performance (e.g. comparable speed to C) -->

<!-- -- -->

<!-- Functions are made generic by paying attention to types and making sure types are .hi-blue[stable] -->

<!-- -- -->

<!-- .hi-blue[Type stability:] Given an input into a function, operations on that input should maintain the type so Julia **knows** what its type will be throughout the full function call -->

<!-- -- -->

<!-- This allows it to compile type-specialized versions of the functions, which will yield higher performance -->

<!-- --- -->

<!-- # Generic functions -->

<!-- The question you might have is: Type stability sounds like mandating types (e.g. what C and Fortran do, not what R/Python/etc do), so how do we make it flexible? -->

<!-- -- -->

<!-- We'll see next -->

<!-- --- -->

<!-- # These two functions look the same, but are they? -->

<!-- ```{julia, results = 'hide'} -->
<!-- function t1(n) -->
<!--   s = 0 -->
<!--   t = 1 -->
<!--   for i in 1:n -->
<!--      s += s/i -->
<!--      t = div(t, i) -->
<!--   end -->
<!--   return t -->
<!-- end -->
<!-- ``` -->
<!-- ```{julia, results = 'hide'} -->
<!-- function t2(n) -->
<!--   s  = 0.0 -->
<!--   t = 1 -->
<!--   for i in 1:n -->
<!--      s += s/i -->
<!--      t = div(t, i) -->
<!--   end -->
<!--   return t -->
<!-- end -->
<!-- ``` -->

<!-- --- -->

<!-- # No! t1 is not type stable -->

<!-- -- -->

<!-- `t1` starts with `s` as an `Int64` but then we have `s += s/i` which will mean it must hold a `Float64` -->

<!-- -- -->

<!-- It must be converted to `Float` so it is not type stable -->

<!-- --- -->

<!-- # No! t1 is not type stable -->

<!-- We can see this when calling the macro `@code_warntype` where it reports `t1` at some point handles `s` that has type `Union{Float64,Int64}`, either `Float64` or `Int64` -->

<!-- Julia now can't assume `s`'s type and produce pure integer or floating point code $\rightarrow$ performance degradation -->

<!-- <div align="center"> -->
<!--   <img src="figures/t1_codewarn.png" height=150> -->
<!--   <img src="figures/t2_codewarn.png" height=150> -->
<!-- </div> -->

<!-- --- -->

<!-- # THIS MATTERS -->

<!-- Here's an order of magnitude difference for a similar function -->
<!-- ```{julia, results = 'hide'} -->
<!-- # Type instable -->
<!-- function type_unstable() -->
<!--   x=1 -->
<!--   for i = 1:10 -->
<!--     x = x/2 -->
<!--   end -->
<!--   return x -->
<!-- end -->
<!-- # Type stable -->
<!-- function type_stable() -->
<!--   x=1.0 -->
<!--   for i = 1:10 -->
<!--     x = x/2 -->
<!--   end -->
<!--   return x -->
<!-- end -->
<!-- ``` -->

<!-- --- -->

<!-- # THIS MATTERS -->

<!-- Here's an order of magnitude difference for a similar function -->

<!-- ```{julia} -->
<!-- @btime type_unstable() -->
<!-- @btime type_stable() -->
<!-- ``` -->

<!-- --- -->

<!-- # Concrete vs abstract types -->

<!-- A **concrete type** is one that can be instantiated (`Float64` `Bool` `Int32`) -->

<!-- -- -->

<!-- An **abstract type** cannot (`Real`, `Number`, `Any`) -->

<!-- --- -->

<!-- # Concrete vs abstract types -->

<!-- Abstract types are for organizing the types -->

<!-- You can check where types are in the hierarchy -->

<!-- ```{julia} -->
<!-- @show Float64 <: Real -->
<!-- @show Array <: Real -->
<!-- @show Number <: Any -->
<!-- ``` -->

<!-- --- -->

<!-- # Concrete vs abstract types -->

<!-- You can see the type hierarchy with the supertypes and subtypes commands -->

<!-- ```{julia} -->
<!-- using Base: show_supertypes -->
<!-- show_supertypes(Float64) -->
<!-- ``` -->

<!-- --- -->

<!-- # Creating new types -->

<!-- We can actually create new composite types using `struct` -->

<!-- -- -->

<!-- ```{julia} -->
<!-- struct FoobarNoType # This will be immutable by default -->
<!--   a -->
<!--   b -->
<!--   c -->
<!-- end -->
<!-- ``` -->

<!-- --- -->

<!-- # Creating new types -->

<!-- This creates a new type called `FoobarNoType`, and we can generate a variable of this type using its **constructor** which will have the same name -->

<!-- -- -->

<!-- ```{julia} -->
<!-- newfoo = FoobarNoType(1.3, 2, "plzzz"); -->
<!-- typeof(newfoo) -->
<!-- newfoo.a -->
<!-- ``` -->

<!-- -- -->

<!-- .hi-red[You should always declare types for the fields of a new composite type] -->

<!-- --- -->

<!-- # Creating new types -->

<!-- You can declare types with the double colon -->


<!-- ```{julia} -->
<!-- struct FoobarType # This will be immutable by default -->
<!--   a::Float64 -->
<!--   b::Int -->
<!--   c::String -->
<!-- end -->
<!-- ``` -->

<!-- --- -->

<!-- # Creating new types -->

<!-- ```{julia} -->
<!-- newfoo_typed = FoobarType(1.3, 2, "plzzz"); -->
<!-- typeof(newfoo_typed) -->
<!-- newfoo.a -->
<!-- ``` -->

<!-- This lets the compiler generate efficient code because it knows the types of the fields when you construct a `FoobarType` -->

<!-- Declaring abstract types isn't good enough, you need to declare concrete types...r do we? -->

<!-- --- -->

<!-- # Parametric types are what help deliver flexibility -->

<!-- We can create types that hold different types of fields -->
<!-- by declaring subsets of abstract types -->

<!-- ```{julia} -->
<!-- struct FooParam{t1 <: Real, t2 <: Real, t3 <: AbstractArray{<:Real}} -->
<!--   a::t1 -->
<!--   b::t2 -->
<!--   c::t3 -->
<!-- end -->
<!-- newfoo_para = FooParam(1.0, 7, [1., 4., 6.]) -->
<!-- ``` -->

<!-- -- -->

<!-- The curly brackets declare all the different type subsets we will use in `FooParam` -->

<!-- -- -->

<!-- This actually delivers high performance code! -->

<!-- --- -->

<!-- # Delivering flexibility -->

<!-- We want to make sure types are stable but code is flexible -->

<!-- Ex: if want to preallocate an array to store data, -->
<!-- how do we know how to declare it's type? -->

<!-- -- -->

<!-- We don't need to -->

<!-- --- -->

<!-- # Delivering flexibility -->

<!-- ```{julia} -->
<!-- using LinearAlgebra               # necessary for I -->
<!-- function sametypes(x) -->
<!--   y = similar(x)                  # creates an array that is `similar` to x, use this for preallocating -->
<!--   z = I                           # creates a scalable identity matrix -->
<!--   q = ones(eltype(x), length(x))  # one is a type generic array of ones, fill creates the array of length(x) -->
<!--   y .= z * x + q -->
<!--   return y -->
<!-- end -->

<!-- x = [5.5, 7.0, 3.1]; -->
<!-- y = [7, 8, 9]; -->
<!-- ``` -->

<!-- --- -->

<!-- # Delivering flexibility -->

<!-- We did not declare any types but the function is type stable -->


<!-- ```{julia, results = 'hide'} -->
<!-- sametypes(x) -->
<!-- sametypes(y) -->
<!-- ``` -->

<!-- <div align="center"> -->
<!--   <img src="figures/generic_codewarn_float.png" height=125> -->
<!--   <img src="figures/generic_codewarn_int.png" height=125> -->
<!-- </div> -->

<!-- -- -->

<!-- There's a lot of other functions out there that help with writing flexible, type stable code -->

<!-- --- -->

<!-- # Multiple dispatch -->

<!-- .hi-red[Why type stability really matters: multiple dispatch] -->

<!-- Neat thing about Julia: the same function name can perform different operations depending on the underlying type of the inputs -->

<!-- A function specifies different **methods**, each of which operates on a specific set of types -->

<!-- --- -->

<!-- # Multiple dispatch -->

<!-- When you write a function that's type stable, you are actually writing many different methods, each of which are optimized for certain types -->

<!-- -- -->

<!-- If your function isn't type stable, the optimized method may not be used -->

<!-- This is why Julia can achieve C speeds: it compiles to C (or faster) code -->

<!-- --- -->

<!-- # Multiple dispatch -->

<!-- `/` has 103 different methods depending on the input types, these are 103 specialized sets of codes -->

<!-- ```{julia} -->
<!-- methods(/) -->
<!-- ``` -->


<!-- --- -->

<!-- # Coding practices etc -->

<!-- See [JuliaPraxis](https://github.com/JuliaPraxis) for best practices for naming, spacing, comments, etc -->



